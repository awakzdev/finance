<!DOCTYPE html>
<html lang="en" dir="ltr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Investment Strategy Comparison</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns@2.0.0"></script>    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.0/papaparse.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            padding: 20px;
            display: flex;
            flex-direction: column;
            direction: ltr; /* Ensure body content direction is LTR */
            text-align: left; /* Align text to the left */
        }

        /* Style the date dropdown */
        .dropdown {
            appearance: none;
            -webkit-appearance: none;
            -moz-appearance: none;
            width: 100%;
            padding: 12px 15px; /* Increase padding for better text positioning */
            font-size: 16px;
            line-height: 1.6; /* Increase line-height to center text vertically */
            border: 1px solid #ccc;
            border-radius: 5px;
            background-color: #f9f9f9;
            background-image: url('data:image/svg+xml;charset=US-ASCII,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path fill="%23999" d="M7 10l5 5 5-5z"/></svg>');
            background-repeat: no-repeat;
            background-position: right 10px center;
            background-size: 12px;
            cursor: pointer;
            transition: border-color 0.3s, box-shadow 0.3s;
        }

        /* Set a specific height */
        .dropdown {
            height: 45px; /* Set a specific height to ensure consistency */
        }

        /* Style on hover */
        .dropdown:hover {
            border-color: #888;
            box-shadow: 0 0 5px rgba(0, 0, 0, 0.1);
        }

        /* Style on focus */
        .dropdown:focus {
            border-color: #4CAF50;
            outline: none;
            box-shadow: 0 0 5px rgba(76, 175, 80, 0.5);
        }

        .header {
            display: flex;
            justify-content: flex-start;
            align-items: center;
            margin-bottom: 20px;
            text-align: left; /* Ensure text aligns to the left */
        }

        button {
            margin-left: auto;
            padding: 10px 20px;
            font-size: 16px;
            background-color: #4CAF50; /* Green background */
            color: white; /* White text */
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s;
            text-align: center; /* Center button text */
        }

        button:hover {
            background-color: #45a049; /* Darker green on hover */
        }

        .main-content {
            display: flex;
            justify-content: space-between;
            flex-direction: row;
            text-align: left; /* Ensure text aligns to the left */
        }

        .left-section {
            flex: 1;
            max-width: 300px;
            text-align: left; /* Ensure text aligns to the left */
        }

        .right-section {
            flex: 2;
            padding-left: 20px;
            text-align: left; /* Ensure text aligns to the left */
        }

        .input-group {
            margin-bottom: 20px;
            display: flex;
            flex-direction: column;
            text-align: left; /* Ensure text aligns to the left */
        }

        .input-group label {
            margin-bottom: 5px;
            font-weight: bold;
            text-align: left; /* Ensure text aligns to the left */
        }

        .slider {
            width: 100%;
            margin-top: 5px;
            direction: ltr; /* Ensure sliders are LTR */
        }

        .results {
            margin-top: 30px;
            padding: 20px;
            background-color: #f4f4f4;
            border-radius: 5px;
            text-align: left; /* Ensure text aligns to the left */
        }

        canvas {
            width: auto;
            height: auto; /* Maintain aspect ratio */
            max-height: 800px; /* Set a maximum height */
        }
    </style>
</head>
<body>
    <!-- Header with Download CSV Button -->
    <div class="header">
        <h1>Investment Strategy Comparison</h1>
        <button id="downloadCSV" onclick="downloadCSV()">Download CSV</button>
    </div>

    <!-- Main Content Area -->
    <div class="main-content">
        <!-- Left Section: Controls and Results -->
        <div class="left-section">
            <!-- Sliders and Controls -->

            <div class="input-group">
                <label for="dateRange">Select Opening Range:</label>
                <select id="dateRange" class="dropdown">
                    <!-- Options will be populated dynamically -->
                </select>
            </div>            
            
            <div class="input-group">
                <label for="closingDate">Select Closing Date:</label>
                <select id="closingDate" class="dropdown">
                    <!-- Options will be populated dynamically -->
                </select>
            </div>

            
            <div class="input-group">
                <label for="totalInvestment">Total Investment ($): <span id="totalInvestmentValue">100000</span></label>
                <input type="range" id="totalInvestment" class="slider" min="50000" max="200000" value="100000" step="1000">
            </div>
            <div class="input-group">
                <label for="split">Investment vs. Cash Split (%): <span id="splitValue">50%</span></label>
                <input type="range" id="split" class="slider" min="0" max="100" value="50" step="1">
            </div>
            <div class="input-group">
                <label for="buyThreshold">Buy Threshold (% drop): <span id="buyThresholdValue">5%</span></label>
                <input type="range" id="buyThreshold" class="slider" min="1" max="20" value="5" step="1">
            </div>
            <div class="input-group">
                <label for="sellThreshold">Sell Threshold (% increase): <span id="sellThresholdValue">10%</span></label>
                <input type="range" id="sellThreshold" class="slider" min="1" max="30" value="10" step="1">
            </div>
            <div class="input-group">
                <label for="buyAmountPercent">Buy Percentage from Cash (%): <span id="buyAmountPercentValue">10%</span></label>
                <input type="range" id="buyAmountPercent" class="slider" min="1" max="50" value="10" step="1">
            </div>

            <!-- Results Section -->
            <div class="results">
                <h2>Results</h2>
                <p><strong>Total Investment:</strong> $<span id="totalValueDisplay">100000</span></p>
                <p><strong>Buy Amount on Each Purchase:</strong> $<span id="buyAmountDisplay">Calculating...</span></p>
                <p><strong>Available Money for Active Investment:</strong> $<span id="availableMoneyDisplay">Calculating...</span></p>
                <p><strong>Stocks Left:</strong> <span id="stocksLeft">Calculating...</span> <span id="stocksValue">($Calculating...)</span></p>
                <p><strong>Final Portfolio Value (Active + Passive):</strong> $<span id="finalTotalValue">Calculating...</span></p>
            </div>
        </div>

        <!-- Right Section: Graph -->
        <div class="right-section">
            <canvas id="totalPortfolioChart"></canvas>
        </div>
    </div>

    <script>
        let stockData = [];
        let ndxStockData = []; // Corrected array name
        let totalPortfolioChart;  // Chart.js instance for the total portfolio
        let datasetsLoaded = 0; // Counter to track loaded datasets

        // Select elements
        const totalInvestmentSlider = document.getElementById('totalInvestment');
        const splitSlider = document.getElementById('split');
        const buyThresholdSlider = document.getElementById('buyThreshold');
        const sellThresholdSlider = document.getElementById('sellThreshold');
        const buyAmountPercentSlider = document.getElementById('buyAmountPercent');
        const dateRangeDropdown = document.getElementById('dateRange');

        const totalInvestmentValue = document.getElementById('totalInvestmentValue');
        const splitValue = document.getElementById('splitValue');
        const buyThresholdValue = document.getElementById('buyThresholdValue');
        const sellThresholdValue = document.getElementById('sellThresholdValue');
        const buyAmountPercentValue = document.getElementById('buyAmountPercentValue');
        const totalValueDisplay = document.getElementById('totalValueDisplay');
        const buyAmountDisplay = document.getElementById('buyAmountDisplay');
        const finalTotalValueDisplay = document.getElementById('finalTotalValue');
        const stocksLeftDisplay = document.getElementById('stocksLeft');
        const stocksValueDisplay = document.getElementById('stocksValue');
        const availableMoneyDisplay = document.getElementById('availableMoneyDisplay');

        // Automatically load the CSV files when the page loads
        window.onload = function() {
            console.log("Fetching CSV files...");

            // Fetch QLD data
            fetch('https://raw.githubusercontent.com/awakzdev/finance/main/qld_stock_data.csv')
            .then(response => response.text())
            .then(csvText => {
                parseCSVData(csvText, 'QLD');
            })
            .catch(error => {
                console.error("Error fetching QLD CSV file:", error);
            });

            // Fetch NDX data
            fetch('https://raw.githubusercontent.com/awakzdev/finance/main/ndx_stock_data.csv')
            .then(response => response.text())
            .then(csvText => {
                parseCSVData(csvText, 'NDX');
            })
            .catch(error => {
                console.error("Error fetching NDX CSV file:", error);
            });

            // Add event listeners to sliders here
            totalInvestmentSlider.addEventListener('input', () => {
                totalInvestmentValue.textContent = totalInvestmentSlider.value;
                calculateResults();
            });

            splitSlider.addEventListener('input', () => {
                splitValue.textContent = `${splitSlider.value}%`;
                calculateResults();
            });

            buyThresholdSlider.addEventListener('input', () => {
                buyThresholdValue.textContent = `${buyThresholdSlider.value}%`;
                calculateResults();
            });

            sellThresholdSlider.addEventListener('input', () => {
                sellThresholdValue.textContent = `${sellThresholdSlider.value}%`;
                calculateResults();
            });

            buyAmountPercentSlider.addEventListener('input', () => {
                buyAmountPercentValue.textContent = `${buyAmountPercentSlider.value}%`;
                calculateResults();
            });

            // Add event listener to the closing date dropdown
            document.getElementById('closingDate').addEventListener('change', () => {
                calculateResults(); // Recalculate results when the closing date changes
            });

            // Add event listener to the date range dropdown
            dateRangeDropdown.addEventListener('change', () => {
                calculateResults(); // Recalculate results when date range changes
            });
        };

        function parseCSVData(csvText, type) {
            Papa.parse(csvText, {
                header: true,
                dynamicTyping: true,
                complete: function(results) {
                    console.log(`CSV data parsed successfully for ${type}.`);

                    const dateKey = results.data.length > 0 && ('Date' in results.data[0]) ? 'Date' : 'date';
                    const closePriceKey = 'Close';
                    const openPriceKey = 'Open';

                    if (!dateKey || !closePriceKey || !openPriceKey) {
                        console.error(`CSV data for ${type} is missing required columns ('Date', 'Close', or 'Open').`);
                        finalTotalValueDisplay.textContent = 'Invalid data: Missing columns';
                        return;
                    }

                    const parsedData = results.data
                        .filter(row => {
                            const dateStr = row[dateKey];
                            const price = row[closePriceKey];
                            const openPrice = row[openPriceKey];

                            if (!dateStr || isNaN(price) || isNaN(openPrice)) {
                                console.warn(`Skipping invalid row in ${type} data:`, row);
                                return false;
                            }
                            return true;
                        })
                        .map(row => {
                            const dateStr = row[dateKey].trim();
                            const [dayStr, monthStr, yearStr] = dateStr.split('/');
                            const day = parseInt(dayStr);
                            const month = parseInt(monthStr);
                            const year = parseInt(yearStr);

                            return {
                                date: dateStr,
                                price: row[closePriceKey],
                                openPrice: row[openPriceKey],
                                dateObj: new Date(year, month - 1, day) // Store date object for easier comparison
                            };
                        });

                    console.log(`${type} parsed data dates:`, parsedData.map(d => d.date));

                    if (parsedData.length > 0) {
                        if (type === 'QLD') {
                            stockData = parsedData;
                            console.log("QLD stock data loaded. Total entries:", stockData.length);
                        } else if (type === 'NDX') {
                            ndxStockData = parsedData;
                            console.log("NDX stock data loaded. Total entries:", ndxStockData.length);
                        }

                        datasetsLoaded++;
                        if (datasetsLoaded === 2) {
                            // Both datasets are loaded, proceed to setup
                            setupChart();
                            populateDateDropdown();
                            calculateResults();
                        }
                    } else {
                        console.error(`Invalid data: No valid stock data found for ${type}.`);
                        finalTotalValueDisplay.textContent = 'Invalid data';
                    }
                },
                error: function(error) {
                    console.error(`Error parsing CSV data for ${type}:`, error);
                }
            });
        }


        function populateDateDropdown() {
            // Combine dates from both datasets
            const combinedDates = [...stockData, ...ndxStockData].map(data => data.date);
            const uniqueDates = [...new Set(combinedDates)];

            // Sort the dates in ascending order
            uniqueDates.sort((a, b) => {
                const [aDay, aMonth, aYear] = a.split('/');
                const [bDay, bMonth, bYear] = b.split('/');
                const aDate = new Date(parseInt(aYear), parseInt(aMonth) - 1, parseInt(aDay));
                const bDate = new Date(parseInt(bYear), parseInt(bMonth) - 1, parseInt(bDay));
                return aDate - bDate;
            });

            // Clear existing options in the dropdowns
            dateRangeDropdown.innerHTML = '';
            const closingDateDropdown = document.getElementById('closingDate');
            closingDateDropdown.innerHTML = '';

            // Add unique dates to both dropdowns
            uniqueDates.forEach(date => {
                const option1 = document.createElement('option');
                option1.value = date;
                option1.textContent = date;
                dateRangeDropdown.appendChild(option1);

                const option2 = document.createElement('option');
                option2.value = date;
                option2.textContent = date;
                closingDateDropdown.appendChild(option2);
            });

            // Set the initial values
            dateRangeDropdown.value = uniqueDates[0];
            closingDateDropdown.value = uniqueDates[uniqueDates.length - 1]; // Set the initial closing date to the last date
        }

        function calculateResults() {
            console.log("Calculating portfolio results...");

            // Get the selected start and closing dates from the dropdowns
            const selectedStartDate = document.getElementById('dateRange').value;
            const selectedClosingDate = document.getElementById('closingDate').value;

            // Convert the selected dates to Date objects for comparison
            const startDateObj = parseDate(selectedStartDate);
            const endDateObj = parseDate(selectedClosingDate);

            console.log("Selected start date:", startDateObj);
            console.log("Selected end date:", endDateObj);

            // Filter stock data to include only dates within the selected range
            const filteredStockData = stockData.filter(data => {
                const isInDateRange = data.dateObj >= startDateObj && data.dateObj <= endDateObj;
                return isInDateRange;
            });

            const filteredNDXStockData = ndxStockData.filter(data => {
                const isInDateRange = data.dateObj >= startDateObj && data.dateObj <= endDateObj;
                return isInDateRange;
            });

            console.log("Filtered QLD data dates:", filteredStockData.map(d => d.date));
            console.log("Filtered NDX data dates:", filteredNDXStockData.map(d => d.date));

            if (!filteredStockData.length || !filteredNDXStockData.length) {
                console.error("No stock data available for the selected date range.");
                finalTotalValueDisplay.textContent = 'No data';
                updateChart([], [], [], []);  // Clear the chart if no data
                return;
            }

            // console.log("Filtered stock data for calculations:", filteredStockData);
            // console.log("Filtered NDX stock data for calculations:", filteredNDXStockData);

            // Initialize values for the calculation
            let totalPortfolioValue = parseInt(totalInvestmentSlider.value);
            let cashPercent = parseInt(splitSlider.value) / 100;
            let buyAmountPercent = parseFloat(buyAmountPercentSlider.value) / 100;
            let buyThreshold = parseFloat(buyThresholdSlider.value) / 100;
            let sellThreshold = parseFloat(sellThresholdSlider.value) / 100;

            // Initialize values for the calculation
            let initialCash = totalPortfolioValue * cashPercent; // Initial cash available for active trading
            let cash = initialCash;
            let initialPassiveInvestment = totalPortfolioValue * (1 - cashPercent); // Initial passive portfolio value
            let passiveShares = initialPassiveInvestment / filteredStockData[0].openPrice; // Equivalent passive investment shares based on Open price
            let passiveInvestmentPrice = filteredStockData[0].openPrice; // Store the price at which passive stocks were purchased
            let activeInvestments = []; // Array to track each active investment separately
            let totalProfit = 0;
            let highestPeak = filteredStockData[0].price; // Initialize the highest peak as the closing price of the first day
            let currentPeak = highestPeak; // Track current peak after the first purchase
            let bought = false; // Track if an initial buy has occurred
            let activeCashInvested = 0; // Total cash invested in active investments

            const totalPortfolioValues = [];
            const activeProfits = [];
            const transactionLog = [];

            // Iterate over filtered stock data for calculations
            filteredStockData.forEach((data, index) => {
                let price = data.price; // This is the closing price
                let action = 'Hold';
                let sharesBought = 0;
                let sharesSold = 0;

                // Update the highest peak using the closing price for the first buy only
                if (!bought && price > highestPeak) {
                    highestPeak = price;
                    currentPeak = price; // Set current peak as the new highest
                }

                // Calculate the percentage drop from the current peak
                const dropFromCurrentPeak = ((currentPeak - price) / currentPeak) * 100;

                // Active trading logic: avoid buying on the first day
                if (index !== 0) { // Skip buying on the first day
                    // Buy logic
                    if (!bought) { // Initial buy
                        if (price <= highestPeak * (1 - buyThreshold)) {
                            // Perform the buy
                            let buyAmount = cash * buyAmountPercent;
                            let sharesToBuy = Math.floor(buyAmount / price);

                            if (sharesToBuy > 0 && cash >= sharesToBuy * price) {
                                cash -= sharesToBuy * price;
                                activeInvestments.push({ buyPrice: price, shares: sharesToBuy });
                                action = 'Buy';
                                sharesBought = sharesToBuy;
                                activeCashInvested += sharesToBuy * price;

                                // Set the flag to indicate the initial buy has occurred
                                bought = true;

                                // Update currentPeak to the price of the initial buy
                                currentPeak = price;
                            }
                        }
                    } else { // Subsequent buys
                        // Update the current peak if the price has increased
                        if (price > currentPeak) {
                            currentPeak = price;
                        }

                        // Buy if the price drops by the buy threshold
                        if (dropFromCurrentPeak >= (buyThreshold * 100)) {
                            let buyAmount = cash * buyAmountPercent;
                            let sharesToBuy = Math.floor(buyAmount / price);

                            if (sharesToBuy > 0 && cash >= sharesToBuy * price) {
                                cash -= sharesToBuy * price;
                                activeInvestments.push({ buyPrice: price, shares: sharesToBuy });
                                action = 'Buy';
                                sharesBought = sharesToBuy;
                                activeCashInvested += sharesToBuy * price;

                                // After the buy, reset currentPeak to the price of this purchase
                                currentPeak = price;
                            }
                        }
                    }

                    // Sell logic: check each batch of shares for sell condition
                    activeInvestments = activeInvestments.map(investment => {
                        if (price >= investment.buyPrice * (1 + sellThreshold)) {
                            // Sell the shares from this batch
                            let saleProceeds = investment.shares * price;
                            totalProfit += (saleProceeds - (investment.shares * investment.buyPrice));
                            cash += saleProceeds;
                            sharesSold = investment.shares;
                            action = 'Sell';

                            // Mark these shares as sold
                            return { ...investment, shares: 0 };
                        }
                        return investment;
                    }).filter(investment => investment.shares > 0); // Keep only investments with shares > 0
                }

                // Calculate values for active and passive portfolios
                const activeInvestmentValue = cash - initialCash + totalProfit + activeInvestments.reduce((sum, inv) => sum + inv.shares * price, 0);
                const passivePortfolioValue = passiveShares * price;
                const totalValue = activeInvestmentValue + passivePortfolioValue;
                const passiveProfit = (price - passiveInvestmentPrice) * passiveShares;
                const activeProfit = totalProfit + activeInvestments.reduce((sum, inv) => sum + inv.shares * price, 0);

                totalPortfolioValues.push(totalValue);
                activeProfits.push(activeProfit);

                transactionLog.push({
                    date: data.date,
                    action: action,
                    sharesBought: sharesBought,
                    sharesSold: sharesSold,
                    price: price,
                    openPrice: data.openPrice,
                    totalCash: cash.toFixed(2),
                    stocksHeld: activeInvestments.reduce((sum, inv) => sum + inv.shares, 0),
                    passiveShares: passiveShares,
                    totalShares: activeInvestments.reduce((sum, inv) => sum + inv.shares, 0) + passiveShares,
                    highestPeak: highestPeak,
                    downPercentageFromPeak: dropFromCurrentPeak.toFixed(2),
                    passiveInvestmentPrice: passiveInvestmentPrice,
                    passiveProfit: passiveProfit.toFixed(2),
                    activeProfit: activeProfit.toFixed(2),
                    activeCashInvested: activeCashInvested.toFixed(2),
                    totalValue: totalValue.toFixed(2),
                    totalAmount: (cash + passivePortfolioValue).toFixed(2),
                    valuePassive: (passiveShares * price).toFixed(2)
                });
            });

            console.log("Calculation complete. Final portfolio value:", totalPortfolioValues[totalPortfolioValues.length - 1]);

            const finalPortfolioValue = totalPortfolioValues[totalPortfolioValues.length - 1];
            buyAmountDisplay.textContent = Math.floor(initialCash * (buyAmountPercentSlider.value / 100)).toFixed(0);
            finalTotalValueDisplay.textContent = finalPortfolioValue.toFixed(2);
            stocksLeftDisplay.textContent = activeInvestments.reduce((sum, inv) => sum + inv.shares, 0);
            stocksValueDisplay.textContent = `($${(activeInvestments.reduce((sum, inv) => sum + inv.shares * filteredStockData[filteredStockData.length - 1].price, 0)).toFixed(2)})`;
            availableMoneyDisplay.textContent = cash.toFixed(2);

            // Calculate NDX passive investment
            let ndxInitialInvestment = 100000; // Hardcoded value
            let ndxPassiveShares = ndxInitialInvestment / filteredNDXStockData[0].openPrice;
            let ndxPortfolioValues = filteredNDXStockData.map(data => ndxPassiveShares * data.price);

            updateChart(filteredStockData, totalPortfolioValues, activeProfits, filteredNDXStockData, ndxPortfolioValues);
            window.transactionLog = transactionLog;

            // Log final portfolio values
            // console.log("Final portfolio values:", totalPortfolioValues);
        }

        function parseDate(dateStr) {
            const [dayStr, monthStr, yearStr] = dateStr.trim().split('/');
            const day = parseInt(dayStr);
            const month = parseInt(monthStr);
            const year = parseInt(yearStr);

            if (isNaN(day) || isNaN(month) || isNaN(year)) {
                console.error(`Invalid date format: ${dateStr}`);
                return null;
            }

            return new Date(year, month - 1, day);
        }

        // Ensure the chart is updated based on the filtered data
        function updateChart(filteredStockData, totalPortfolioValues, activeProfits, filteredNDXStockData, ndxPortfolioValues) {
            totalPortfolioChart.data.labels = filteredStockData.map(data => data.date);
            totalPortfolioChart.data.datasets[0].data = totalPortfolioValues;
            totalPortfolioChart.data.datasets[1].data = activeProfits;

            // Update NDX dataset
            totalPortfolioChart.data.datasets[2].data = ndxPortfolioValues;
            totalPortfolioChart.update();
        }

        // Function to initialize the Chart.js chart
        function setupChart() {
            const ctx = document.getElementById('totalPortfolioChart').getContext('2d');
            totalPortfolioChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: [], // Labels will be updated dynamically
                    datasets: [
                        {
                            label: 'Total Portfolio Value',
                            data: [],  // Empty initially, will be populated
                            backgroundColor: 'rgba(75, 192, 192, 0.2)',
                            borderColor: 'rgba(75, 192, 192, 1)',
                            borderWidth: 1,
                            fill: true
                        },
                        {
                            label: 'Active Profit',
                            data: [],  // Empty initially, will be populated
                            backgroundColor: 'rgba(255, 99, 132, 0.2)',
                            borderColor: 'rgba(255, 99, 132, 1)',
                            borderWidth: 1,
                            fill: true
                        },
                        {
                            label: 'NDX Passive Investment',
                            data: [],  // Empty initially, will be populated
                            backgroundColor: 'rgba(54, 162, 235, 0.2)',
                            borderColor: 'rgba(54, 162, 235, 1)',
                            borderWidth: 1,
                            fill: true
                        }
                    ]
                },
                options: {
                    scales: {
                        y: {
                            beginAtZero: false
                        }
                    }
                }
            });
        }

        // Function to download the CSV file
        function downloadCSV() {
            const csvRows = [];
            const headers = [
                'Date', 'Action', 'Shares Bought', 'Shares Sold', 'Price', 'Open Price', 
                'Total Cash', 'Stocks Held', 'Passive Shares', 'Total Shares', 'Highest Peak', 
                'Down Percentage from Peak', 'Passive Investment Price', 'Passive Profit', 
                'Active Profit', 'Active Cash Invested', 'Total Value', 'Total Amount', 'Value Passive'
            ];
            csvRows.push(headers.join(','));

            window.transactionLog.forEach(log => {
                const row = [
                    log.date,
                    log.action,
                    log.sharesBought,
                    log.sharesSold,
                    log.price,
                    log.openPrice,
                    log.totalCash,
                    log.stocksHeld,
                    log.passiveShares,
                    log.totalShares,
                    log.highestPeak,
                    log.downPercentageFromPeak,
                    log.passiveInvestmentPrice,
                    log.passiveProfit,
                    log.activeProfit,
                    log.activeCashInvested,
                    log.totalValue,
                    log.totalAmount,
                    log.valuePassive
                ];
                csvRows.push(row.join(','));
            });

            const csvContent = csvRows.join('\n');
            const blob = new Blob([csvContent], { type: 'text/csv' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.setAttribute('href', url);
            a.setAttribute('download', 'investment_strategy_log.csv');
            a.click();
        }
    </script>
</body>
</html>
