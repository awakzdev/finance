<!DOCTYPE html>
<html lang="en" dir="ltr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Investment Strategy Comparison</title>
    <!-- Chart.js -->
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    <!-- Moment.js -->
    <script src="https://cdn.jsdelivr.net/npm/moment@2.29.4/min/moment.min.js"></script>
    <!-- Papa Parse for CSV parsing -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.0/papaparse.min.js"></script>


    <style>
        body {
            font-family: Arial, sans-serif;
            padding: 20px;
            display: flex;
            flex-direction: column;
            direction: ltr;
            text-align: left;
        }

        /* Style the date dropdown */
        .dropdown {
            appearance: none;
            -webkit-appearance: none;
            -moz-appearance: none;
            width: 100%;
            padding: 10px 15px;
            font-size: 16px;
            line-height: 1.6;
            border: 1px solid #ccc;
            border-radius: 5px;
            background-color: #f9f9f9;
            cursor: pointer;
            transition: border-color 0.3s, box-shadow 0.3s;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            height: auto;
            display: block;
            box-sizing: border-box;
        }

        .header {
            display: flex;
            justify-content: flex-start;
            align-items: center;
            margin-bottom: 20px;
            text-align: left;
        }

        button {
            margin-left: auto;
            padding: 10px 20px;
            font-size: 16px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s;
            text-align: center;
        }

        .main-content {
            display: flex;
            justify-content: space-between;
            flex-direction: row;
            text-align: left;
            flex-wrap: nowrap;
        }

        .left-section {
            flex: 0 1 300px;
            min-width: 300px;
            margin-right: 20px;
            text-align: left;
        }

        .right-section {
            flex: 1;
            padding-left: 20px;
            text-align: left;
        }

        .input-group {
            margin-bottom: 20px;
            display: flex;
            flex-direction: column;
            text-align: left;
        }

        .input-group label {
            margin-bottom: 5px;
            font-weight: bold;
            text-align: left;
        }

        .slider {
            width: 100%;
            margin-top: 5px;
            direction: ltr;
        }

        .results {
            margin-top: 30px;
            padding: 20px;
            background-color: #f4f4f4;
            border-radius: 5px;
            text-align: left;
            box-sizing: border-box;
        }

        .modebar {
        position: absolute !important;
        top: 0;
        left: 0;
        width: 100%;
        z-index: 1;
        }
        #totalPortfolioChart {
            position: relative; 
            height: 600px;
        }

        canvas {
            width: auto;
            height: auto;
            max-height: 800px;
        }

        /* Toggle Switch */
        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 40px;
            height: 20px;
            margin-right: 10px;
            vertical-align: middle;
        }

        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: 0.4s;
            border-radius: 20px; 
        }

        .toggle-slider:before {
            position: absolute;
            content: "";
            height: 16px;
            width: 16px;
            left: 2px;
            bottom: 2px;
            background-color: white;
            transition: 0.4s;
            border-radius: 50%;
        }

        input:checked + .toggle-slider {
            background-color: #4CAF50;
        }

        input:checked + .toggle-slider:before {
            transform: translateX(20px);
        }

        .input-group {
            margin-bottom: 20px;
        }
        

    </style>
</head>
<body>
    <div class="header">
        <h1>Investment Strategy Comparison</h1>
        <button id="downloadCSV" class="download-btn" onclick="downloadCSV()">Download CSV</button>
    </div>

    <!-- Main Content Area -->
    <div class="main-content">
        <!-- Left Section: Controls and Results -->
        <div class="left-section">
            <!-- Sliders and Controls -->
            <div class="input-group">
                <label for="dateRange">Select Opening Range:</label>
                <select id="dateRange" class="dropdown">
                </select>
            </div>

            <div class="input-group">
                <label for="closingDate">Select Closing Date:</label>
                <select id="closingDate" class="dropdown">
                </select>
            </div>

            <div class="input-group">
                <label for="totalInvestment">Total Investment ($):</label>
                <select id="totalInvestment" class="dropdown">
                    <option value="50000">50,000</option>
                    <option value="100000" selected>100,000</option> <!-- Set as default -->
                    <option value="200000">200,000</option>
                    <option value="500000">500,000</option>
                    <option value="1000000">1,000,000</option>
                    <option value="5000000">5,000,000</option>
                    <option value="10000000">10,000,000</option>
                </select>
            </div>
            
            <div class="input-group">
                <label for="allowNegativeBalance">
                    <div class="toggle-switch">
                        <input type="checkbox" id="allowNegativeBalance">
                        <span class="toggle-slider"></span>
                    </div>
                    Allow Negative Balance
                </label>
            </div>
            
            
            <div class="input-group">
                <label for="split">Investment vs. Cash Split (%): <span id="splitValue">50%</span></label>
                <input type="range" id="split" class="slider" min="0" max="100" value="50" step="1">
            </div>
            <div class="input-group">
                <label for="buyThreshold">Buy Threshold (% drop): <span id="buyThresholdValue">5%</span></label>
                <input type="range" id="buyThreshold" class="slider" min="1" max="20" value="5" step="1">
            </div>
            <div class="input-group">
                <label for="sellThreshold">Sell Threshold (% increase): <span id="sellThresholdValue">10%</span></label>
                <input type="range" id="sellThreshold" class="slider" min="1" max="30" value="10" step="1">
            </div>
            <div class="input-group">
                <label for="buyAmountPercent">Buy Percentage from Cash (%): <span id="buyAmountPercentValue">10%</span></label>
                <input type="range" id="buyAmountPercent" class="slider" min="1" max="50" value="10" step="1">
            </div>

            <!-- Results Section -->
            <div class="results">
                <h2>Results</h2>
                <p><strong>Total Investment:</strong> $<span id="totalValueDisplay">100000</span></p>
                <p><strong>Buy Amount on Each Purchase:</strong> $<span id="buyAmountDisplay">Calculating...</span></p>
                <p><strong>Available Money for Active Investment:</strong> $<span id="availableMoneyDisplay">Calculating...</span></p>
                <p><strong>Stocks Left:</strong> <span id="stocksLeft">Calculating...</span> <span id="stocksValue">($Calculating...)</span></p>
                <p><strong>Final Portfolio Value (Active + Passive):</strong> $<span id="finalTotalValue">Calculating...</span></p>
            </div>
        </div>

        <!-- Right Section: Graph -->
        <div class="right-section">
            <div id="totalPortfolioChart"></div>
        </div>
    </div>

    <script>
        // JavaScript code
        let stockData = [];
        let ndxStockData = [];
        let totalPortfolioChart;
        let datasetsLoaded = 0;
        let allowNegativeBalance = false; // Declare globally

        // Select elements
        const totalInvestmentSlider = document.getElementById('totalInvestment');
        const splitSlider = document.getElementById('split');
        const buyThresholdSlider = document.getElementById('buyThreshold');
        const sellThresholdSlider = document.getElementById('sellThreshold');
        const buyAmountPercentSlider = document.getElementById('buyAmountPercent');
        const dateRangeDropdown = document.getElementById('dateRange');
        const totalInvestmentDropdown = document.getElementById('totalInvestment');

        const totalInvestmentValue = document.getElementById('totalInvestmentValue');
        const splitValue = document.getElementById('splitValue');
        const buyThresholdValue = document.getElementById('buyThresholdValue');
        const sellThresholdValue = document.getElementById('sellThresholdValue');
        const buyAmountPercentValue = document.getElementById('buyAmountPercentValue');
        const totalValueDisplay = document.getElementById('totalValueDisplay');
        const buyAmountDisplay = document.getElementById('buyAmountDisplay');
        const finalTotalValueDisplay = document.getElementById('finalTotalValue');
        const stocksLeftDisplay = document.getElementById('stocksLeft');
        const stocksValueDisplay = document.getElementById('stocksValue');
        const availableMoneyDisplay = document.getElementById('availableMoneyDisplay');

        window.onload = function() {
            console.log("Fetching CSV files...");

            fetch('https://raw.githubusercontent.com/awakzdev/finance/main/qld_stock_data.csv')
            .then(response => response.text())
            .then(csvText => {
                parseCSVData(csvText, 'QLD');
            })
            .catch(error => {
                console.error("Error fetching QLD CSV file:", error);
            });

            fetch('https://raw.githubusercontent.com/awakzdev/finance/main/^ndx_stock_data.csv')
            .then(response => response.text())
            .then(csvText => {
                parseCSVData(csvText, 'NDX');
            })
            .catch(error => {
                console.error("Error fetching NDX CSV file:", error);
            });

            // Set up the event listener for negative balance checkbox
            const checkbox = document.getElementById('allowNegativeBalance');
            checkbox.addEventListener('change', function() {
                allowNegativeBalance = this.checked; // Update the variable
                console.log('Checkbox state:', allowNegativeBalance); // Log the current state
                calculateResults(); // Recalculate results when the checkbox state changes
            });

            // Event listener for the new dropdown
            totalInvestmentDropdown.addEventListener('change', () => {
                totalValueDisplay.textContent = totalInvestmentDropdown.value;

                calculateResults();
            });

            splitSlider.addEventListener('input', () => {
                splitValue.textContent = `${splitSlider.value}%`;
                calculateResults();
            });

            buyThresholdSlider.addEventListener('input', () => {
                buyThresholdValue.textContent = `${buyThresholdSlider.value}%`;
                calculateResults();
            });

            sellThresholdSlider.addEventListener('input', () => {
                sellThresholdValue.textContent = `${sellThresholdSlider.value}%`;
                calculateResults();
            });

            buyAmountPercentSlider.addEventListener('input', () => {
                buyAmountPercentValue.textContent = `${buyAmountPercentSlider.value}%`;
                calculateResults();
            });

            document.getElementById('closingDate').addEventListener('change', () => {
                calculateResults(); // Recalculate results when the closing date changes
            });

            dateRangeDropdown.addEventListener('change', () => {
                calculateResults(); // Recalculate results when date range changes
            });
        };


        function parseCSVData(csvText, type) {
            Papa.parse(csvText, {
                header: true,
                dynamicTyping: true,
                complete: function(results) {
                    console.log(`CSV data parsed successfully for ${type}.`);

                    const dateKey = results.data.length > 0 && ('Date' in results.data[0]) ? 'Date' : 'date';
                    const closePriceKey = 'Close';
                    const openPriceKey = 'Open';
                    const highPriceKey = 'High';
                    const lastBuyKey = 'Buy';
                    const sellPriceKey = 'Sell'
                    const lowPriceKey = 'Low';

                    if (!dateKey || !closePriceKey || !openPriceKey) {
                        console.error(`CSV data for ${type} is missing required columns ('Date', 'Close', or 'Open').`);
                        finalTotalValueDisplay.textContent = 'Invalid data: Missing columns';
                        return;
                    }

                    const parsedData = results.data
                        .filter(row => {
                            const dateStr = row[dateKey];
                            const price = row[closePriceKey];
                            const openPrice = row[openPriceKey];
                            const highPrice = row[highPriceKey];
                            const lowPrice = row[lowPriceKey];

                            if (!dateStr || isNaN(price) || isNaN(openPrice)) {
                                console.warn(`Skipping invalid row in ${type} data:`, row);
                                return false;
                            }
                            return true;
                        })
                        .map(row => {

                            const dateStr = row[dateKey].trim();
                            const [dayStr, monthStr, yearStr] = dateStr.split('/');
                            const day = parseInt(dayStr);
                            const month = parseInt(monthStr);
                            const year = parseInt(yearStr);

                            return {
                                date: dateStr,
                                price: row[closePriceKey],
                                openPrice: row[openPriceKey],
                                highPrice: row[highPriceKey],
                                lastBuy: row[lastBuyKey],
                                sellPrice: row[sellPriceKey],
                                lowPrice: row[lowPriceKey],
                                dateObj: new Date(year, month - 1, day) // Store date object for easier comparison
                            };
                        });

                    if (parsedData.length > 0) {
                        if (type === 'QLD') {
                            stockData = parsedData;
                            console.log("QLD stock data loaded. Total entries:", stockData.length);
                        } else if (type === 'NDX') {
                            ndxStockData = parsedData;
                            console.log("NDX stock data loaded. Total entries:", ndxStockData.length);
                        }

                        datasetsLoaded++;
                        if (datasetsLoaded === 2) {
                            populateDateDropdown();
                            setupChart();
                            calculateResults();
                        }
                    } else {
                        console.error(`Invalid data: No valid stock data found for ${type}.`);
                        finalTotalValueDisplay.textContent = 'Invalid data';
                    }
                },
                error: function(error) {
                    console.error(`Error parsing CSV data for ${type}:`, error);
                }
            });
        }

        function populateDateDropdown() {
            // Combine dates from both datasets
            const combinedDates = [...stockData, ...ndxStockData].map(data => data.dateObj.getTime());
            const uniqueDatesSet = new Set(combinedDates);
            const uniqueDates = Array.from(uniqueDatesSet).map(time => new Date(time));

            // Sort the dates in ascending order
            uniqueDates.sort((a, b) => a - b);

            // Clear existing options in the dropdowns
            dateRangeDropdown.innerHTML = '';
            const closingDateDropdown = document.getElementById('closingDate');
            closingDateDropdown.innerHTML = '';

            // Add unique dates to both dropdowns
            uniqueDates.forEach(dateObj => {
                const dateStr = formatDate(dateObj);

                const option1 = document.createElement('option');
                option1.value = dateStr;
                option1.textContent = dateStr;
                dateRangeDropdown.appendChild(option1);

                const option2 = document.createElement('option');
                option2.value = dateStr;
                option2.textContent = dateStr;
                closingDateDropdown.appendChild(option2);
            });

            // Set the opening date to '26/07/2019' if it exists
            const defaultDate = '26/07/2019';
            const defaultDateExists = Array.from(dateRangeDropdown.options).some(option => option.value === defaultDate);

            if (defaultDateExists) {
                dateRangeDropdown.value = defaultDate;
            } else {
                // Fallback to the first date if the default date isn't found
                dateRangeDropdown.value = formatDate(uniqueDates[0]);
            }

            // Always set the closing date to the last date in the dataset
            closingDateDropdown.value = formatDate(uniqueDates[uniqueDates.length - 1]);

            // Trigger the initial calculation
            calculateResults();
        }


        function calculateResults() {
            console.log("Calculating portfolio results...");

            const buyPoints = [];
            const sellPoints = [];
            const totalCashValues = []; // Array to store total cash values

            // Get the selected start and closing dates from the dropdowns
            const selectedStartDate = document.getElementById('dateRange').value;
            const selectedClosingDate = document.getElementById('closingDate').value;

            // Convert the selected dates to Date objects for comparison
            const startDateObj = parseDate(selectedStartDate);
            const endDateObj = parseDate(selectedClosingDate);

            console.log("Selected start date:", startDateObj);
            console.log("Selected end date:", endDateObj);

            // Filter stock data to include only dates within the selected range
            const filteredStockData = stockData.filter(data => {
                const isInDateRange = data.dateObj >= startDateObj && data.dateObj <= endDateObj;
                return isInDateRange;
            });

            const filteredNDXStockData = ndxStockData.filter(data => {
                const isInDateRange = data.dateObj >= startDateObj && data.dateObj <= endDateObj;
                return isInDateRange;
            });

            console.log("Filtered QLD data dates:", filteredStockData.map(d => d.date));
            console.log("Filtered NDX data dates:", filteredNDXStockData.map(d => d.date));

            if (!filteredStockData.length || !filteredNDXStockData.length) {
                console.error("No stock data available for the selected date range.");
                finalTotalValueDisplay.textContent = 'No data';
                updateChart([], [], [], [], []); // Include totalCashValues in the updateChart call
                return;
            }

            // Initialize variables
            let totalPortfolioValue = parseInt(totalInvestmentDropdown.value);
            let cashPercent = parseInt(splitSlider.value) / 100;
            let buyAmountPercent = parseFloat(buyAmountPercentSlider.value) / 100;
            let buyThreshold = parseFloat(buyThresholdSlider.value) / 100;
            let sellThreshold = parseFloat(sellThresholdSlider.value) / 100;

            let initialCash = totalPortfolioValue * cashPercent; // Cash allocated for active trading
            let initialBuyAmount = initialCash * buyAmountPercent; // Fix the initial buy amount per purchase
            let cash = initialCash;
            let initialPassiveInvestment = totalPortfolioValue * (1 - cashPercent); // Passive investment
            let passiveShares = initialPassiveInvestment / filteredStockData[0].openPrice;
            let passiveInvestmentPrice = filteredStockData[0].openPrice;
            let activeInvestments = [];
            let totalProfit = 0;
            let highestPeak = filteredStockData[0].price;
            let lastBuyPrice = filteredStockData[0].highPrice; // Tracks the last buy price for tracking subsequent drops
            let currentPeak = highestPeak;
            let purchaseCount = 0; // Track the number of purchases made
            let bought = false;
            let activeCashInvested = 0;
            let firstPurchasePeak = null; // Peak at the time of the first purchase
            let fullySold = true; // Flag to indicate if all stocks are sold

            const totalPortfolioValues = [];
            const activeProfits = [];
            const transactionLog = [];

            // Iterate over filtered stock data for calculations
            filteredStockData.forEach((data, index) => {
                const dataDate = data.dateObj;
                let price = data.lowPrice;
                let action = 'Hold';
                let sharesBought = 0;
                let sharesSold = 0;
                let didBuy = false
                let didSell = false
                fullySold = (activeInvestments.length === 0)
                // Update the highest peak (always check if price exceeds the highestPeak)
                if (data.price > highestPeak) {  // 'price' here refers to the closePrice as defined earlier
                    highestPeak = data.price;
                }

                // Compare highest peak to high price of the day
                // if (data.price > highestPeak) { 
                //     highestPeak = data.highPrice;
                // }

                // If fully sold, reset the first purchase peak and purchase count
                if (fullySold) {
                    firstPurchasePeak = highestPeak;
                    purchaseCount = 0; // Reset purchase count
                }
                
                let buy_price = null;
                let sellPrice = null;
                let buyPricesLog = ''; // Initialize a variable to store buy prices for the day

                let peakToUse = fullySold ? highestPeak : firstPurchasePeak;

                // currentPeak = highestPeak * (1-Threshold) ^ (numbers of active stock)
                // currentPeak = peakToUse * Math.pow(1 - buyThreshold, activeInvestments.length);
                currentPeak = peakToUse - peakToUse * buyThreshold * activeInvestments.length
                // Calculate drop from current peak
                const dropFromCurrentPeak = ((currentPeak - price) / currentPeak) * 100;
                
                // Buy logic (before the first purchase)
                if (dropFromCurrentPeak >= buyThreshold * 100) {
                    // Loop to check for multiple purchases on the same day
                    while (dropFromCurrentPeak >= buyThreshold * 100) {
                        // Calculate the drop percentage for the current purchase
                        currentPurchaseCount = activeInvestments.length + 1; // Increment based on the number of purchases made
                        dropPercentage = buyThreshold * currentPurchaseCount * 100; // Calculate the specific drop percentage

                        // Calculate the new buy price
                        buy_price = peakToUse - (peakToUse * buyThreshold * currentPurchaseCount)

                        let sharesToBuy = initialBuyAmount / buy_price; // Use initialBuyAmount for purchase size

                        // Check if there is enough cash to buy the shares
                        if (sharesToBuy > 0 && (cash >= sharesToBuy * buy_price || (allowNegativeBalance && cash < sharesToBuy * buy_price))) {
                            cash -= sharesToBuy * buy_price;
                            activeInvestments.push({ buyPrice: buy_price, shares: sharesToBuy });
                            action = 'Buy';
                            sharesBought += sharesToBuy; // Increment if multiple buys are made
                            activeCashInvested += sharesToBuy * buy_price;

                            // Append the buy price to the log string
                            if (buyPricesLog === '') {
                                buyPricesLog = buy_price.toFixed(4);
                            }
                            // This line logs multiple prices to our CSV if more than one purchases were made
                            else {
                                buyPricesLog += `; ${buy_price.toFixed(4)}`;
                            }

                            didBuy = true

                            // Align Buy points with active portfolio value
                            let activeInvestmentValue = cash - initialCash + totalProfit + activeInvestments.reduce((sum, inv) => sum + inv.shares * price, 0);

                            // Update last buy price and current peak for subsequent buys
                            lastBuyPrice = buy_price;
                            currentPeak = buy_price;
                        } else {
                            break; // Break the loop if no more cash is available
                        }

                        // Recalculate drop from current peak after the purchase
                        const newDropFromCurrentPeak = ((currentPeak - price) / currentPeak) * 100;
                        if (newDropFromCurrentPeak < buyThreshold * 100) {
                            break; // Break the loop if no further purchases can be made
                        }
                    }
                }

                // Sell logic with high price check
                activeInvestments = activeInvestments.map(investment => {
                    // Calculate the exact target sell price (10% increase from buy price)
                    const targetSellPrice = investment.buyPrice * (1 + sellThreshold);
                    
                    // Check if the high price of the day exceeds or equals the target sell price
                    if (data.highPrice >= targetSellPrice) {
                        // Sell the shares at the target sell price
                        let saleProceeds = investment.shares * targetSellPrice; // Use targetSellPrice for sale
                        totalProfit += (saleProceeds - (investment.shares * investment.buyPrice));
                        cash += saleProceeds;
                        sharesSold = investment.shares;
                        action = 'Sell';
                        didSell=true
                        sellPrice = targetSellPrice; // Record the target sell price as the sell price

                        gainPercentage = ((targetSellPrice - investment.buyPrice) / investment.buyPrice) * 100;

                        // Align Sell points with active portfolio value
                        let activeInvestmentValue = cash - initialCash + totalProfit + activeInvestments.reduce((sum, inv) => sum + inv.shares * price, 0);

                        // Mark shares as sold
                        return { ...investment, shares: 0 };
                    }
                    return investment;
                }).filter(investment => investment.shares > 0); // Keep investments with shares > 0

                // Calculate portfolio values
                const activeInvestmentValue = cash + activeInvestments.reduce((sum, inv) => sum + inv.shares * price, 0);
                const passivePortfolioValue = passiveShares * price;
                const totalValue = activeInvestmentValue + passivePortfolioValue;
                const passiveProfit = (price - passiveInvestmentPrice) * passiveShares;
                const activeProfit = totalProfit + activeInvestments.reduce((sum, inv) => sum + inv.shares * price, 0);

                totalPortfolioValues.push({ x: dataDate, y: totalValue });
                totalCashValues.push({ x: dataDate, y: cash }); // Store the cash value for this date

                // activeProfits.push({ x: dataDate, y: activeProfit });
                // Log buy and sell points on the graph
                if(didSell){
                    // Determine marker properties based on the threshold
                    
                    let markerProperties = getMarkerProperties('sell', gainPercentage);

                    // Log the sell point with marker properties
                    sellPoints.push({
                        x: dataDate, // Keep as date object
                        y: totalValue,
                        marker: {
                            color: markerProperties.color,
                            symbol: markerProperties.shape,
                            size: 8
                        },
                        hovertext: `Sell: ${data.date}, Gain: ${gainPercentage.toFixed(2)}%`                    });
                }
                if(didBuy){
                    // Determine marker properties based on the threshold
                    let markerProperties = getMarkerProperties('buy', dropPercentage);

                    // Log the buy point with marker properties
                    buyPoints.push({
                        x: dataDate, // Keep as date object
                        y: totalValue,
                        marker: {
                            color: markerProperties.color,
                            symbol: markerProperties.shape,
                            size: 8
                        },
                        hovertext: `Buy: ${data.date}, Drop: ${dropPercentage.toFixed(2)}%` // Use data.date directly for hovertext
                    });
                }

                // Modify the transaction log to store the new price fields
                transactionLog.push({
                    date: data.date,
                    action: action,
                    sharesBought: sharesBought,
                    sharesSold: sharesSold,
                    openPrice: data.openPrice,
                    lastBuy: buyPricesLog, // Log multiple buy prices
                    sellPrice: sellPrice,
                    highPrice: data.highPrice,
                    lowPrice: data.lowPrice,
                    closePrice: data.price,
                    totalCash: cash.toFixed(2),
                    stocksHeld: activeInvestments.reduce((sum, inv) => sum + inv.shares, 0),
                    passiveShares: passiveShares,
                    totalShares: activeInvestments.reduce((sum, inv) => sum + inv.shares, 0) + passiveShares,
                    highestPeak: highestPeak,
                    downPercentageFromPeak: dropFromCurrentPeak.toFixed(2),
                    passiveInvestmentPrice: passiveInvestmentPrice,
                    passiveProfit: passiveProfit.toFixed(2),
                    activeProfit: activeProfit.toFixed(2),
                    activeCashInvested: activeCashInvested.toFixed(2),
                    totalValue: totalValue.toFixed(2),
                    totalAmount: (cash + passivePortfolioValue).toFixed(2),
                    valuePassive: (passiveShares * price).toFixed(2)
                });
            });

            console.log("Calculation complete. Final portfolio value:", totalPortfolioValues[totalPortfolioValues.length - 1]);

            const finalPortfolioValue = totalPortfolioValues[totalPortfolioValues.length - 1].y;
            buyAmountDisplay.textContent = Math.floor(initialCash * (buyAmountPercentSlider.value / 100)).toFixed(0);
            finalTotalValueDisplay.textContent = finalPortfolioValue.toFixed(2);
            stocksLeftDisplay.textContent = activeInvestments.reduce((sum, inv) => sum + inv.shares, 0).toFixed(2);
            stocksValueDisplay.textContent = `($${(activeInvestments.reduce((sum, inv) => sum + inv.shares * filteredStockData[filteredStockData.length - 1].price, 0)).toFixed(2)})`;
            availableMoneyDisplay.textContent = cash.toFixed(2);

            // Calculate NDX passive investment
            let ndxInitialInvestment = 100000; // Assuming the same initial investment
            let ndxPassiveShares = ndxInitialInvestment / filteredNDXStockData[0].openPrice;
            let ndxPortfolioValues = filteredNDXStockData.map(data => {
                return {
                    x: data.dateObj,
                    y: ndxPassiveShares * data.price
                };
            });

            updateChart(totalPortfolioValues, activeProfits, ndxPortfolioValues, buyPoints, sellPoints, totalCashValues); // Pass totalCashValues to updateChart
            window.transactionLog = transactionLog;
        }

        function parseDate(dateStr) {
            const [dayStr, monthStr, yearStr] = dateStr.trim().split('/');
            const day = parseInt(dayStr);
            const month = parseInt(monthStr);
            const year = parseInt(yearStr);

            if (isNaN(day) || isNaN(month) || isNaN(year)) {
                console.error(`Invalid date format: ${dateStr}`);
                return null;
            }

            return new Date(year, month - 1, day);
        }

        function formatDate(dateObj) {
            const day = String(dateObj.getDate()).padStart(2, '0');
            const month = String(dateObj.getMonth() + 1).padStart(2, '0');
            const year = dateObj.getFullYear();
            return `${day}/${month}/${year}`;
        }
        
        function getMarkerProperties(action, threshold) {
            // Define shapes and colors for different percentages
            const markerShapes = {
                'buy': {
                    '5%': { color: 'green', shape: 'circle' },
                    '10%': { color: 'cyan', shape: 'diamond-open' },
                    '15%': { color: 'purple', shape: 'hexagon' },
                    '20%': { color: 'orange', shape: 'triangle-up' },
                    '25%': { color: 'blue', shape: 'star' },
                    '30%': { color: 'magenta', shape: 'triangle-down' },
                    '35%': { color: 'brown', shape: 'square' },
                    '40%': { color: 'yellow', shape: 'triangle-right' },
                    '45%': { color: 'coral', shape: 'triangle-left' },
                    '50%': { color: 'teal', shape: 'cross' },
                    '55%': { color: 'olive', shape: 'x' },
                    '60%': { color: 'lime', shape: 'octagon' },
                    '65%': { color: 'indigo', shape: 'star-square' },
                    '70%': { color: 'violet', shape: 'pentagon' },
                    '75%': { color: 'gold', shape: 'hourglass' },
                    '80%': { color: 'navy', shape: 'diamond' }
                },
                'sell': {
                    '5%': { color: 'red', shape: 'cross' },
                    '10%': { color: 'pink', shape: 'star' },
                    '15%': { color: 'brown', shape: 'x' },
                    '20%': { color: 'yellow', shape: 'triangle-down' },
                }
            };

            // Convert threshold to a string key (e.g., '10%')
            const key = `${Math.round(threshold)}%`;

            // Return the appropriate marker properties or a fallback for undefined thresholds
            if (markerShapes[action][key]) {
                return markerShapes[action][key];
            } else {
                // Fallback for any other threshold
                return {
                    color: action === 'buy' ? 'blue' : 'red', // Differentiate by action
                    shape: action === 'buy' ? 'triangle-right' : 'triangle-left' // Differentiate by action
                };
            }
        }

        function setupChart() {
            const totalPortfolioValues = [];
            const activeProfits = [];
            const ndxPortfolioValues = [];
            const totalCashValues = []; // Include this to avoid errors during initial setup

            const layout = {
                title: 'Portfolio Values Over Time',
                xaxis: {
                    title: 'Date',
                    type: 'date',
                },
                yaxis: {
                    title: 'Value ($)',
                },
                margin: {
                    l: 50, // left margin
                    r: 50, // right margin
                    t: 20, // top margin - reduce this to make more space
                    b: 50, // bottom margin
                }
            };


            const config = {
                displaylogo: false, // Remove the Plotly logo
                displayModeBar: true, // Always show the mode bar
            };

            Plotly.newPlot('totalPortfolioChart', [
                {
                    x: totalPortfolioValues.map(data => data.x),
                    y: totalPortfolioValues.map(data => data.y),
                    mode: 'lines',
                    name: 'Total Portfolio Value',
                    line: { color: 'rgba(75, 192, 192, 1)' },
                    fill: 'tozeroy',
                },
                {
                    x: activeProfits.map(data => data.x),
                    y: activeProfits.map(data => data.y),
                    mode: 'lines',
                    name: 'Active Profit',
                    line: { color: 'rgba(255, 99, 132, 1)' },
                    fill: 'tozeroy',
                },
                {
                    x: ndxPortfolioValues.map(data => data.x),
                    y: ndxPortfolioValues.map(data => data.y),
                    mode: 'lines',
                    name: 'NDX Passive Investment',
                    line: { color: 'rgba(54, 162, 235, 1)' },
                    fill: 'tozeroy',
                }
            ], layout, config);
        }

        function updateChart(totalPortfolioValues, activeProfits, ndxPortfolioValues, buyPoints, sellPoints, totalCashValues) {
            const allXValues = [
                ...totalPortfolioValues.map(data => data.x),
                ...ndxPortfolioValues.map(data => data.x),
                ...buyPoints.map(point => point.x),
                ...sellPoints.map(point => point.x),
                ...totalCashValues.map(data => data.x) // Include total cash dates
            ];

            // Calculate the min and max dates for the x-axis range
            const minXValue = Math.min(...allXValues);
            const maxXValue = Math.max(...allXValues);

            const updatedData = [
                {
                    x: totalPortfolioValues.map(data => data.x),
                    y: totalPortfolioValues.map(data => data.y),
                    name: 'Total Portfolio Value',
                    mode: 'lines',
                },
                {
                    x: ndxPortfolioValues.map(data => data.x),
                    y: ndxPortfolioValues.map(data => data.y),
                    name: 'NDX Passive Investment',
                    mode: 'lines',
                },
                {
                    x: totalCashValues.map(data => data.x), // Add total cash to the chart
                    y: totalCashValues.map(data => data.y),
                    name: 'Total Cash',
                    mode: 'lines',
                    line: { dash: 'dot', color: 'rgba(255, 165, 0, 1)' } // Dashed orange line for cash
                },
                // Buy Points
                {
                    x: buyPoints.map(point => point.x),
                    y: buyPoints.map(point => point.y),
                    mode: 'markers',
                    name: 'Buy Points',
                    marker: {
                        color: buyPoints.map(point => point.marker.color),
                        symbol: buyPoints.map(point => point.marker.symbol),
                        size: 8,
                    },
                    hoverinfo: 'text',
                    text: buyPoints.map(point => point.hovertext),
                },
                // Sell Points
                {
                    x: sellPoints.map(point => point.x),
                    y: sellPoints.map(point => point.y),
                    mode: 'markers',
                    name: 'Sell Points',
                    marker: {
                        color: sellPoints.map(point => point.marker.color),
                        symbol: sellPoints.map(point => point.marker.symbol),
                        size: 8,
                    },
                    hoverinfo: 'text',
                    text: sellPoints.map(point => point.hovertext),
                }
            ];

            const layout = {
                title: 'Portfolio Values Over Time',
                xaxis: {
                    title: 'Date',
                    type: 'date',
                    range: [minXValue, maxXValue],
                },
                yaxis: {
                    title: 'Value ($)',
                },
                hovermode: 'closest', // Enable 'closest' hover mode by default
                legend: {
                    orientation: 'h', // Horizontal orientation
                    x: 0.5, // Center the legend horizontally
                    y: 1.0, // Move the legend higher above the chart
                    xanchor: 'center', // Center the legend's x position
                    yanchor: 'bottom', // Align the legend's y position to the bottom
                                },
                margin: {
                    l: 50, // Left margin
                    r: 50, // Right margin
                    t: 70, // Increase top margin to fit the legend
                    b: 50, // Bottom margin
                },
            };

            Plotly.react('totalPortfolioChart', updatedData, layout);
        }

        // Update the CSV download logic
        function downloadCSV() {
            const csvRows = [];
            const headers = [
                'Date', 'Action', 'Shares Bought', 'Shares Sold','Buy Price', 'Sell Price', 'Open Price', 'High Price', 'Low Price', 'Close Price',
                'Total Cash', 'Stocks Held', 'Passive Shares', 'Total Shares', 'Highest Peak',
                'Passive Profit', //'Down Percentage from Peak', 'Passive Investment Price', 'Total Amount',
                'Active Profit', 'Active Cash Invested', 'Total Value', 'Value Passive'
            ];
            csvRows.push(headers.join(','));

            window.transactionLog.forEach(log => {
                const row = [
                    log.date,
                    log.action,
                    log.sharesBought,
                    log.sharesSold,
                    log.lastBuy,
                    log.sellPrice,
                    log.openPrice,
                    log.highPrice, // Add High Price
                    log.lowPrice,  // Add Low Price
                    log.closePrice, // Add Close Price (instead of price)
                    log.totalCash,
                    log.stocksHeld,
                    log.passiveShares,
                    log.totalShares,
                    log.highestPeak,
                    // log.downPercentageFromPeak,
                    // log.passiveInvestmentPrice,
                    log.passiveProfit,
                    log.activeProfit,
                    log.activeCashInvested,
                    log.totalValue,
                    // log.totalAmount,
                    log.valuePassive
                ];
                csvRows.push(row.join(','));

            });

            const csvContent = csvRows.join('\n');
            const blob = new Blob([csvContent], { type: 'text/csv' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.setAttribute('href', url);
            a.setAttribute('download', 'investment_strategy_log.csv');
            a.click();
        }
    </script>
</body>
</html>
