<!DOCTYPE html>
<html lang="en" dir="ltr">
<head>
    <!-- Head content remains the same -->
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Investment Strategy Comparison</title>
    <!-- Chart.js -->
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    <!-- Moment.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/moment.js/2.30.1/moment.min.js"></script>
    <!-- Papa Parse for CSV parsing -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>
    <!-- Font Awesome Icons-->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.6.0/css/all.min.css">
    <!-- ajax-->
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>
    <!-- Include this in your <head> to import from Google Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Roboto&family=Open+Sans&family=Montserrat&family=Lato&display=swap">

    <style>
    /* CSS styles remain mostly the same */
    /* Additional styles for new elements */
    body {
        font-family: Arial, sans-serif;
        padding: 20px;
        display: flex;
        flex-direction: column;
        direction: ltr;
        text-align: left;
    }

    /* Header */
    .header {
        display: flex;
        justify-content: flex-start;
        align-items: center;
        margin-bottom: 20px;
        text-align: left;
    }

    .header h1 {
        margin: 0;
        font-size: 1.6em;
        color: #2c3e50;
        font-weight: bold;
    }

    button {
        margin-left: auto;
        padding: 10px 20px;
        font-size: 16px;
        background-color: #4CAF50;
        color: white;
        border: none;
        border-radius: 5px;
        cursor: pointer;
        transition: background-color 0.3s;
    }

    button:hover {
        background-color: #45a049;
    }

    /* Main Content Area */
    .main-content {
        display: flex;
        justify-content: space-between;
        flex-direction: row;
        text-align: left;
        flex-wrap: nowrap;
    }

    .left-section {
        flex: 0 1 300px;
        min-width: 280px;
        margin-right: 20px;
        text-align: left;
        display: flex;
        flex-direction: column;
    }

    .right-section {
        flex: 1;
        padding-left: 20px;
        text-align: left;
    }

    /* Controls Section */
    .controls-section {
        padding-bottom: 10px;
    }

    /* Section Headings */
    .controls-section h3 {
        margin-top: 0;
        margin-bottom: 10px;
        font-size: 1.1em;
        color: #2c3e50;
        border-bottom: 1px solid #e0e4e8;
        padding-bottom: 5px;
        font-weight: bold;
    }

    /* Input Groups */
    .input-group {
        margin-bottom: 15px;
    }

    /* Labels */
    .input-group label {
        margin-bottom: 5px;
        font-weight: bold;
        color: #34495e;
        display: block;
    }

    /* Dropdowns */
    .dropdown, .input-box, .moduleC_input-box {
        width: 100%;
        padding: 5px 10px; /* Adjusted padding */
        font-size: 17px !important;
        line-height: 1.75; /* Increased line-height */
        min-height: 36px; /* Set a minimum height */
        border: 1px solid #ccd6dd;
        border-radius: 5px;
        background-color: #fff;
        transition: border-color 0.3s;
        box-sizing: border-box;
    }
    .moduleC_input-box{
        width: 20%;
    }
    .dropdown:focus, .input-box:focus {
        border-color: #4CAF50;
        outline: none;
    }

    /* Toggle Switch */
    .toggle-switch {
        position: relative;
        display: inline-block;
        width: 40px;
        height: 20px;
        margin-right: 8px;
        vertical-align: middle;
    }

    .toggle-switch input {
        opacity: 0;
        width: 0;
        height: 0;
    }

    .toggle-slider {
        position: absolute;
        cursor: pointer;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background-color: #ccc;
        transition: 0.4s;
        border-radius: 20px;
    }

    .toggle-slider:before {
        position: absolute;
        content: "";
        height: 16px;
        width: 16px;
        left: 2px;
        bottom: 2px;
        background-color: white;
        transition: 0.4s;
        border-radius: 50%;
    }

    input:checked + .toggle-slider {
        background-color: #4CAF50;
    }

    input:checked + .toggle-slider:before {
        transform: translateX(20px);
    }

    /* Icon Buttons for Toggle Switches and Model Selection */
    .icon-toggle {
        display: flex;
        margin-top: 5px;
    }

    .icon-btn {
        flex: 1;
        padding: 10px 12px; /* Unified padding */
        font-size: 14px;
        border: 1px solid #ccd6dd;
        background-color: #fff;
        color: #34495e;
        cursor: pointer;
        transition: background-color 0.3s, color 0.3s;
        height: 40px; /* Unified height */
    }

    .icon-btn:first-child {
        border-right: none;
        border-radius: 5px 0 0 5px;
    }

    .icon-btn:last-child {
        border-radius: 0 5px 5px 0;
    }

    .icon-btn.active {
        background-color: #4CAF50;
        color: #fff;
        border-color: #4CAF50;
    }

    .icon-btn:hover {
        background-color: #e6e6e6;
    }

    /* Container for the slider and its value */
    .slider-container {
        display: flex !important;
        align-items: center !important;
        justify-content: space-between !important;
        margin-bottom: 10px !important; /* Add spacing between sliders */
    }

    .slider-container input[type="range"] {
        flex-grow: 1 !important; /* Make the slider take up most of the space */
        margin-right: 10px !important; /* Add some spacing between slider and value */
    }

    .slider-container .slider-value {
        flex-shrink: 0 !important; /* Ensure the value stays at a fixed size */
        white-space: nowrap !important; /* Prevent the value from wrapping to a new line */
    }

    /* Ensure input-group elements stack properly */
    .input-group {
        margin-bottom: 20px !important;
    }

    /* Optional: Style for slider labels */
    .slider-label {
        display: block !important;
        font-weight: bold !important;
        margin-bottom: 5px !important;
    }

    .slider {
        -webkit-appearance: none;
        width: 100%;
        height: 6px;
        background: #ddd;
        outline: none;
        border-radius: 5px;
        margin-top: 8px;
    }

    .slider::-webkit-slider-thumb {
        -webkit-appearance: none;
        appearance: none;
        width: 16px;
        height: 16px;
        background: #4CAF50;
        cursor: pointer;
        border-radius: 50%;
        transition: background-color 0.3s;
    }

    .slider::-webkit-slider-thumb:hover {
        background-color: #45a049;
    }

    .slider::-moz-range-thumb {
        width: 16px;
        height: 16px;
        background: #4CAF50;
        cursor: pointer;
        border-radius: 50%;
        transition: background-color 0.3s;
    }

    .slider::-moz-range-thumb:hover {
        background-color: #45a049;
    }

    .slider-value {
        margin-left: 8px;
        font-size: 14px;
        color: #2c3e50;
    }

    /* Results */
    .results {
        margin-top: 10px;
        padding: 20px;
        background: linear-gradient(145deg, #f0f4f8, #ffffff);
        border-radius: 12px;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1), inset 0 0 8px rgba(0, 0, 0, 0.05);
        text-align: left;
        box-sizing: border-box;
        border: 1px solid #e0e0e0;
    }

    .results h2 {
        font-size: 1.6em;
        margin-bottom: 15px;
        color: #2c3e50;
        font-weight: bold;
    }

    .result-item {
        display: flex;
        justify-content: space-between;
        margin-bottom: 12px;
        padding: 8px 0;
        border-bottom: 1px solid #e0e4e8;
        line-height: 1.2;
    }

    .result-label {
        font-weight: bold;
        color: #34495e;
    }

    .result-value {
        font-size: 1em;
        color: #000;
        font-weight: bold;
    }

    .results-icon {
        margin-right: 8px;
        color: #4CAF50;
    }

    .bold-label {
        font-weight: bold;
    }

    .custom-dropdown {
        appearance: none;
        background-image: url('data:image/svg+xml;charset=US-ASCII,<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="%2334495e"><polygon points="0,0 16,0 8,8"/></svg>');
        background-repeat: no-repeat;
        background-position: right 10px center;
        background-size: 12px;
        padding-right: 30px;
    }

    .custom-dropdown option {
        padding: 10px;
    }

    .strategy-box {
        display: flex !important;
        align-items: center !important;
        justify-content: center !important;
        text-align: center !important;
        padding: 20px !important;
        box-sizing: border-box !important;
        height: 100% !important;
        width: 100% !important;
        background-color: #f9f9f9 !important;
        border: 1px solid #ccc !important;
        border-radius: 8px !important;
        overflow: hidden !important;
        white-space: normal !important;
        word-wrap: break-word !important;
    }

    .strategy-box p {
        margin: 0 !important;
        line-height: 1.5 !important;
        font-size: 16px !important;
        width: 100% !important;
        vertical-align: middle !important;
    }

    /* Reduce gap between the "Model" label and the selection buttons/dropdown */
    .model-label {
        margin-right: 5px !important;
        font-weight: bold !important;
    }

    .icon-btn {
        padding: 8px 10px !important;
        font-size: 14px !important;
    }

    /* Additional styles for new elements */
    .input-group .input-label {
        font-weight: bold;
        margin-bottom: 5px;
    }
    .input-group .input-field {
        width: 100%;
        padding: 5px 10px;
        font-size: 17px !important;
        line-height: 1.75;
        min-height: 36px;
        border: 1px solid #ccd6dd;
        border-radius: 5px;
        background-color: #fff;
        transition: border-color 0.3s;
        box-sizing: border-box;
    }
    .input-group .input-field:focus {
        border-color: #4CAF50;
        outline: none;
    }

    /* Custom styles for Plotly range selector buttons */
    .custom-range-selector {
        display: flex;
        justify-content: left;
    }

    #customRangeSelector {
        display: flex;
        align-items: center;
    }

    #customRangeSelector button {
        background-color: #f8f9fa; /* Light gray background */
        border: 1px solid #d1d5da; /* Subtle border for definition */
        color: #212529; /* Dark text color for contrast */
        padding: 6px 12px; /* Adjust the padding for a neat look */
        margin: 0 2px;
        font-size: 14px;
        font-family: 'Montserrat', 'Bebas Neue', sans-serif;
        border-radius: 4px;
        cursor: pointer;
        transition: background-color 0.3s, border-color 0.3s, color 0.3s;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    }

    #customRangeSelector .date-icon {
        font-size: 18px;  /* Icon size */
        color: #000000;   /* Icon color (slightly muted) */
        margin-left: 10px; /* Space between the buttons and the icon */
        margin-top: 3px;
    }

    #customRangeSelector button:hover {
        background-color: #e2e6ea; /* Slightly darker background on hover */
        border-color: #b3b6bc; /* Darken the border on hover */
    }

    #customRangeSelector button.active {
        color: #1f98c8; /* White text for active button */
        border-color: #000000;
    }

    /* Model C Customization Styles */
    #modelCContainer {
        margin-top: 20px;
        padding: 15px;
        background-color: #f9f9f9;
        border: 1px solid #e0e0e0;
        border-radius: 8px;
    }

    #modelCContainer h3 {
        font-size: 1.2em;
        margin-bottom: 15px;
        color: #2c3e50;
        font-weight: bold;
    }

    #modelCTable {
        width: 100%;
        border-collapse: collapse;
        margin-bottom: 10px;
    }

    #modelCTable th, #modelCTable td {
        border: 1px solid #ddd;
        padding: 8px;
        /* text-align: left; */
        /* Add this line to reduce font size */
        font-size: 14px; /* Adjust the size as needed */
        /* Optional: Center the text */
        text-align: center;
    }

    #modelCTable th {
        background-color: #f2f2f2;
        font-weight: bold;
    }

    #modelCTable tbody tr:nth-child(even) {
        background-color: #f9f9f9;
    }

    #modelCTable input[type="number"] {
        width: 100%;
        padding: 5px;
        box-sizing: border-box;
        font-size: 14px;
        border: 1px solid #ccd6dd;
        border-radius: 4px;
    }

    #modelCTable input[type="number"]:focus {
        border-color: #4CAF50;
        outline: none;
    }

    /* Style for Add and Remove Row Buttons */
    #modelCButtons {
        margin-top: 10px;
    }

    #modelCButtons button {
        padding: 8px 12px;
        margin-right: 5px;
        font-size: 14px;
        color: #fff;
        background-color: #4CAF50;
        border: none;
        border-radius: 5px;
        cursor: pointer;
        transition: background-color 0.3s;
    }

    #modelCButtons button:hover {
        background-color: #45a049;
    }

    /* Adjust input group styles for Model C */
    #modelCParameters .input-group {
        margin-bottom: 15px;
    }

    #modelCParameters label {
        font-weight: bold;
        margin-bottom: 5px;
    }

    /* Hide the default sliders */
    .hidden {
        display: none !important;
    }

    /* Styles for Reset Threshold Slider */
    #div_resetThresholdValue {
        margin-bottom: 15px;
    }

    #div_resetThresholdValue .slider-label {
        font-weight: bold;
        margin-bottom: 5px;
    }

    #div_resetThresholdValue .slider-container {
        display: flex;
        align-items: center;
        justify-content: space-between;
    }

    #div_resetThresholdValue .slider {
        flex-grow: 1;
        margin-right: 10px;
    }

    #div_resetThresholdValue .slider-value {
        flex-shrink: 0;
        white-space: nowrap;
    }

    /* Styles for Holding Ratio Result Item */
    #holdingRatioResult {
        display: flex;
        justify-content: space-between;
        margin-bottom: 12px;
        padding: 8px 0;
        border-bottom: 1px solid #e0e4e8;
        line-height: 1.2;
    }

    #holdingRatioResult .result-label {
        font-weight: bold;
        color: #34495e;
    }

    #holdingRatioResult .result-value {
        font-size: 1em;
        color: #000;
        font-weight: bold;
    }

    /* Loading Overlay Styles */
    .loading-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(255, 255, 255, 0.8);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 1000;
        opacity: 0;
        visibility: hidden;
        transition: opacity 0.3s, visibility 0.3s;
    }

    .loading-overlay.show {
        opacity: 1;
        visibility: visible;
    }

    .loading-container {
        display: flex;
        flex-direction: column; /* Stack spinner and text vertically */
        align-items: center;    /* Center items horizontally */
        gap: 20px;              /* Add space between spinner and text */
    }

    .spinner {
        border: 6px solid rgba(0, 0, 0, 0.1);
        border-top: 6px solid #4CAF50;
        border-radius: 50%;
        width: 60px;
        height: 60px;
        animation: spin 1s linear infinite;
    }

    @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
    }

    .loading-overlay p {
        font-size: 18px;
        color: #333;
        font-weight: bold;
        margin: 0;
    }

    </style>
</head>
<body>
    <!-- Body Content -->
    <div class="header">
        <h1>Investment Strategy Comparison</h1>
        <button id="downloadCSV" class="download-btn" onclick="downloadCSV()">Download CSV</button>
    </div>

    <!-- Main Content Area -->
    <div class="main-content">
        <!-- Left Section: Controls and Results -->
        <div class="left-section">
            <!-- Controls Section -->
            <div class="controls-section">
                <!-- Date Selection -->
                <div class="input-group">
                    <label for="dateRange">Select Opening Range:</label>
                    <select id="dateRange" class="dropdown custom-dropdown"></select>
                </div>
                <div class="input-group">
                    <label for="closingDate">Select Closing Date:</label>
                    <select id="closingDate" class="dropdown custom-dropdown"></select>
                </div>

                <!-- Investment Settings -->
                <div class="input-group">
                    <label for="totalInvestment">Total Investment ($):</label>
                    <input type="number" id="totalInvestment" class="input-box" value="100000" min="0" step="1000">
                </div>

                <!-- Strategy Options -->
                <label class="bold-label">Select Strategy:</label>
                <div class="input-group">
                    <div class="icon-toggle">
                        <button type="button" id="modelAIcon" class="icon-btn model-btn" style="width: 120px; height: 80px; text-align: center;">
                            <i class="fas fa-chart-line"></i> Model A
                        </button>
                        <button type="button" id="modelBIcon" class="icon-btn model-btn active" style="width: 120px; height: 80px; text-align: center;">
                            <i class="fas fa-chart-bar"></i> Model B
                        </button>
                        <button type="button" id="modelCIcon" class="icon-btn model-btn" style="width: 120px; height: 80px; text-align: center;">
                            <i class="fas fa-chart-pie"></i> Model C
                        </button>
                        <button type="button" id="modelDIcon" class="icon-btn model-btn" style="width: 120px; height: 80px; text-align: center;">
                            <i class="fas fa-chart-area"></i> Model D
                        </button>
                    </div>
                </div>

                <!-- Allow Negative Balance -->
                <div class="input-group">
                    <label>Allow Negative Balance:</label>
                    <div class="icon-toggle">
                        <button type="button" id="negativeBalanceAllow" class="icon-btn">
                            <i class="fas fa-check"></i>
                        </button>
                        <button type="button" id="negativeBalanceDisallow" class="icon-btn active">
                            <i class="fas fa-times"></i>
                        </button>
                    </div>
                </div>
                
                <!-- Always Use Highest Peak Option (Only for Model B) -->
                <div class="input-group" id="alwaysUseHighestPeakOption" style="display: none;">
                    <label>Always Use Highest Peak:</label>
                    <div class="icon-toggle">
                        <button type="button" id="alwaysUseHighestPeakYes" class="icon-btn">
                            <i class="fas fa-check"></i>
                        </button>
                        <button type="button" id="alwaysUseHighestPeakNo" class="icon-btn active">
                            <i class="fas fa-times"></i>
                        </button>
                    </div>
                </div>

                <!-- Sliders -->
                <!-- Investment vs. Cash Split Slider -->
                <div class="input-group" id="investmentCashSplit">
                    <label for="split" class="slider-label">Investment vs. Cash Split (%):</label>
                    <div class="slider-container">
                        <input type="range" id="split" class="slider" min="0" max="100" value="50" step="1">
                        <span class="slider-value" id="splitValue">50%</span>
                    </div>
                </div>

                <!-- Default Sliders -->
                <div id="defaultSliders">
                    <!-- Sell Threshold Slider -->
                    <div class="input-group" id="div_sellThresholdValue">
                        <label for="sellThreshold" class="slider-label">Sell Threshold (% increase):</label>
                        <div class="slider-container">
                            <input type="range" id="sellThreshold" class="slider" min="1" max="30" value="10" step="1">
                            <span class="slider-value" id="sellThresholdValue">10%</span>
                        </div>
                    </div>

                    <!-- Buy Threshold Slider -->
                    <div class="input-group" id="div_buyThresholdValue">
                        <label for="buyThreshold" class="slider-label">Buy Threshold (% drop):</label>
                        <div class="slider-container">
                            <input type="range" id="buyThreshold" class="slider" min="1" max="20" value="5" step="1">
                            <span class="slider-value" id="buyThresholdValue">5%</span>
                        </div>
                    </div>

                    <!-- Buy Percentage from Cash Slider -->
                    <div class="input-group" id="div_buyAmountPercent">
                        <label for="buyAmountPercent" class="slider-label">Buy Percentage from Cash (%):</label>
                        <div class="slider-container">
                            <input type="range" id="buyAmountPercent" class="slider" min="1" max="50" value="10" step="1">
                            <span class="slider-value" id="buyAmountPercentValue">10%</span>
                        </div>
                    </div>
                </div>

                <!-- Model C Customization -->
                <div id="Title_model_c" style="display: none;">
                    <h3>Model C Customization</h3>
                </div>

                <div id="modelCParameters" style="display: none;">
                    <table id="modelCTable" style="width: 100%; border-collapse: collapse;">
                        <thead>
                            <tr>
                                <th style="border: 1px solid #ddd; padding: 8px;">Buy Threshold (%)</th>
                                <th style="border: 1px solid #ddd; padding: 8px;">Buy Percentage from Cash (%)</th>
                                <th style="border: 1px solid #ddd; padding: 8px;">Sell Threshold (%)</th>
                            </tr>
                        </thead>
                        <tbody>
                        </tbody>
                    </table>
                    <div style="margin-top: 10px;">
                        <button id="addRowButton" style="padding: 10px 20px; margin-right: 5px;">Add Row</button>
                        <button id="removeRowButton" style="padding: 10px 20px;">Remove Row</button>
                    </div>
                </div>
            </div>

            <!-- Slider for Model D -->
            <div class="input-group" id="div_resetThresholdValue" style="display: none;">
                <label for="resetThreshold" class="slider-label">Reset Threshold (% deviation):</label>
                <div class="slider-container">
                    <input type="range" id="resetThreshold" class="slider" min="1" max="20" value="5" step="1">
                    <span class="slider-value" id="resetThresholdValue">5%</span>
                </div>
            </div>

            <!-- Results Section -->
            <div class="results">
                <h2><i class="fas fa-chart-pie results-icon"></i> Results</h2>
                <div class="result-item">
                    <span class="result-label"><i class="fas fa-coins results-icon"></i> Total Investment:</span>
                    <span class="result-value">$<span id="totalValueDisplay">100000</span></span>
                </div>
                <div class="result-item">
                    <span class="result-label"><i class="fas fa-shopping-cart results-icon"></i> Buy Amount on Each Purchase:</span>
                    <span class="result-value">$<span id="buyAmountDisplay">Calculating...</span></span>
                </div>
                <div class="result-item">
                    <span class="result-label"><i class="fas fa-wallet results-icon"></i> Available Investment Cash:</span>
                    <span class="result-value">$<span id="availableMoneyDisplay">Calculating...</span></span>
                </div>
                <div class="result-item">
                    <span class="result-label"><i class="fas fa-chart-line results-icon"></i> Stocks Left:</span>
                    <span class="result-value"><span id="stocksLeft">Calculating...</span></span>
                </div>
                <div class="result-item">
                    <span class="result-label"><i class="fas fa-percentage results-icon"></i> Model Yield (%):</span>
                    <span class="result-value"><span id="modelYield">Calculating...</span>%</span>
                </div>
                <div class="result-item">
                    <span class="result-label"><i class="fas fa-percentage results-icon"></i> NDX Yield (%):</span>
                    <span class="result-value"><span id="ndxYield">Calculating...</span>%</span>
                </div>
                <div class="result-item">
                    <span class="result-label"><i class="fas fa-piggy-bank results-icon"></i> Final Portfolio Value (Active + Passive):</span>
                    <span class="result-value">$<span id="finalTotalValue">Calculating...</span></span>
                </div>
                <!-- Holding Ratio for Model D -->
                <div class="result-item" id="holdingRatioResult" style="display: none;">
                    <span class="result-label"><i class="fas fa-balance-scale results-icon"></i> Final Holding Ratio (%):</span>
                    <span class="result-value"><span id="finalHoldingRatio">Calculating...</span>%</span>
                </div>
            </div>
        </div>

        <!-- Right Section: Graph -->
        <div class="right-section">

            <div class="loading-overlay" id="loadingOverlay">
                <div class="loading-container">
                    <div class="spinner"></div>
                    <p>Loading data, please wait...</p>
                </div>
            </div>

            <div id="totalPortfolioChart"></div>
            
            <div id="customRangeSelector" class="custom-range-selector">
                <button data-range="1y">1Y</button>
                <button data-range="2y">2Y</button>
                <button data-range="3y">3Y</button>
                <button data-range="4y">4Y</button>
                <button data-range="5y">5Y</button>
                <button data-range="6y">6Y</button>
                <button data-range="7y">7Y</button>
                <button data-range="8y">8Y</button>
                <button data-range="9y">9Y</button>
                <button data-range="10y">10Y</button>
                <i class="fas fa-calendar-alt date-icon"></i> <!-- Single icon to the right -->
            </div>
            
        </div>
    </div>

    <!-- Scripts -->
    <script>
        let buyPercentages = [], sellPercentages = [], dropPercentages = [];
        let stockData = [];
        let ndxStockData = [];
        let datasetsLoaded = 0;
        let allowNegativeBalance = false;
        let alwaysUseHighestPeak = false;
        let selectedModel = 'modelB';
        let qldCumulativeYields = [];
        let ndxCumulativeYields = [];
        let qldYieldValues = [];
        let holdingRatios = [];
        let minXValue;
        let maxXValue;

        const totalInvestmentInput = document.getElementById('totalInvestment');
        const splitSlider = document.getElementById('split');
        const buyThresholdSlider = document.getElementById('buyThreshold');
        const sellThresholdSlider = document.getElementById('sellThreshold');
        const dateRangeDropdown = document.getElementById('dateRange');
        const closingDateDropdown = document.getElementById('closingDate');
        const totalValueDisplay = document.getElementById('totalValueDisplay');
        const splitValue = document.getElementById('splitValue');
        const buyThresholdValue = document.getElementById('buyThresholdValue');
        const sellThresholdValue = document.getElementById('sellThresholdValue');
        const buyAmountDisplay = document.getElementById('buyAmountDisplay');
        const finalTotalValueDisplay = document.getElementById('finalTotalValue');
        const stocksLeftDisplay = document.getElementById('stocksLeft');
        const stocksValueDisplay = document.getElementById('stocksValue');
        const availableMoneyDisplay = document.getElementById('availableMoneyDisplay');
        const buyAmountPercentSlider = document.getElementById('buyAmountPercent');
        const buyAmountPercentValue = document.getElementById('buyAmountPercentValue');
        const resetThresholdSlider = document.getElementById('resetThreshold');
        const resetThresholdValueDisplay = document.getElementById('resetThresholdValue');
        const holdingRatioResult = document.getElementById('holdingRatioResult');
        const alwaysUseHighestPeakOption = document.getElementById('alwaysUseHighestPeakOption');
        const alwaysUseHighestPeakYesBtn = document.getElementById('alwaysUseHighestPeakYes');
        const alwaysUseHighestPeakNoBtn = document.getElementById('alwaysUseHighestPeakNo');

        function showLoadingOverlay() {
            console.log("Showing loading overlay...");
            const loadingOverlay = document.getElementById('loadingOverlay');
            loadingOverlay.classList.add('show');
        }

        function hideLoadingOverlay() {
            console.log("Hiding loading overlay...");
            const loadingOverlay = document.getElementById('loadingOverlay');
            loadingOverlay.classList.remove('show');
        }

        function getFilteredStockData(dataArray, startDateObj, endDateObj) {
            return dataArray.filter(data => data.dateObj >= startDateObj && data.dateObj <= endDateObj);
        }

        // Debounce function to limit the rate of function calls
        function debounce(func, delay) {
            let debounceTimer;
            return function() {
                const context = this;
                const args = arguments;
                clearTimeout(debounceTimer);
                debounceTimer = setTimeout(() => func.apply(context, args), delay);
            };
        }

        window.onload = function() {
            console.log("Fetching CSV files...");

            // Fetch CSV files
            fetch('https://raw.githubusercontent.com/awakzdev/finance/main/qld_stock_data.csv')
            .then(response => response.text())
            .then(csvText => {
                parseCSVData(csvText, 'QLD');
            })
            .catch(error => {
                console.error("Error fetching QLD CSV file:", error);
            });

            fetch('https://raw.githubusercontent.com/awakzdev/finance/main/ndx_stock_data.csv')
            .then(response => response.text())
            .then(csvText => {
                parseCSVData(csvText, 'NDX');
            })
            .catch(error => {
                console.error("Error fetching NDX CSV file:", error);
            });

            window.addEventListener('resize', () => {
                Plotly.Plots.resize('totalPortfolioChart');
            });

            // Debounced calculateResults function
            const debouncedCalculateResults = debounce(calculateResults, 300);

            // Event listeners for inputs
            totalInvestmentInput.addEventListener('change', () => {
                totalValueDisplay.textContent = totalInvestmentInput.value;
                debouncedCalculateResults();
            });

            splitSlider.addEventListener('input', () => {
                splitValue.textContent = `${splitSlider.value}%`;
                debouncedCalculateResults();
            });

            buyThresholdSlider.addEventListener('input', () => {
                buyThresholdValue.textContent = `${buyThresholdSlider.value}%`;
                debouncedCalculateResults();
            });

            sellThresholdSlider.addEventListener('input', () => {
                sellThresholdValue.textContent = `${sellThresholdSlider.value}%`;
                debouncedCalculateResults();
            });
            
            buyAmountPercentSlider.addEventListener('input', () => {
                buyAmountPercentValue.textContent = `${buyAmountPercentSlider.value}%`;
                debouncedCalculateResults();
            });

            closingDateDropdown.addEventListener('change', function() {
                const selectedStartDate = parseDate(dateRangeDropdown.value);
                const selectedEndDate = parseDate(this.value);
                if (selectedEndDate < selectedStartDate) {
                    alert("End date cannot be before start date.");
                    this.value = dateRangeDropdown.value;
                }
                debouncedCalculateResults();
            });
            dateRangeDropdown.addEventListener('change', function() {
                synchronizeEndDateOptions();
                debouncedCalculateResults();
            });

            document.getElementById('addRowButton').addEventListener('click', () => {
                addRow();
                debouncedCalculateResults();
            });

            document.getElementById('removeRowButton').addEventListener('click', () => {
                removeRow();
                debouncedCalculateResults();
            });

            resetThresholdSlider.addEventListener('input', function () {
                resetThresholdValueDisplay.textContent = resetThresholdSlider.value + '%';
                debouncedCalculateResults();
            });

            // Calls event listener function for date selection
            setupCustomRangeSelector();

            // Add event listeners to always buy from highest peak on model B
            [alwaysUseHighestPeakYesBtn, alwaysUseHighestPeakNoBtn].forEach(function(button) {
                button.addEventListener('click', function() {
                    // Remove 'active' class from both buttons
                    alwaysUseHighestPeakYesBtn.classList.remove('active');
                    alwaysUseHighestPeakNoBtn.classList.remove('active');
                    // Add 'active' class to the clicked button
                    this.classList.add('active');
                    // Update the variable based on the button clicked
                    alwaysUseHighestPeak = this.id === 'alwaysUseHighestPeakYes';
                    console.log('Always Use Highest Peak:', alwaysUseHighestPeak);
                    // Recalculate results
                    debouncedCalculateResults();
                });
            });

            // Event listener for "Allow Negative Balance" buttons
            const negativeBalanceAllowBtn = document.getElementById('negativeBalanceAllow');
            const negativeBalanceDisallowBtn = document.getElementById('negativeBalanceDisallow');
            buyAmountPercentValue.textContent = `${buyAmountPercentSlider.value}%`;
            // Set the "No" option as active by default
            negativeBalanceAllowBtn.classList.remove('active');
            negativeBalanceDisallowBtn.classList.add('active');
            allowNegativeBalance = false; // Ensure it's set to false by default

            [negativeBalanceAllowBtn, negativeBalanceDisallowBtn].forEach(function(button) {
                button.addEventListener('click', function() {
                    negativeBalanceAllowBtn.classList.remove('active');
                    negativeBalanceDisallowBtn.classList.remove('active');
                    this.classList.add('active');
                    allowNegativeBalance = this.id === 'negativeBalanceAllow';
                    console.log('Allow Negative Balance:', allowNegativeBalance);
                    debouncedCalculateResults();
                });
            });

            // Event listener for Strategy Icon Buttons
            const modelAIcon = document.getElementById('modelAIcon');
            const modelBIcon = document.getElementById('modelBIcon');
            const modelCIcon = document.getElementById('modelCIcon');
            const modelDIcon = document.getElementById('modelDIcon');

            function selectModel(model) {
                // Remove 'active' class from all model buttons
                document.querySelectorAll('.model-btn').forEach(function (button) {
                    button.classList.remove('active');
                });
                // Add 'active' class to the selected model button
                document.getElementById(model).classList.add('active');

                // Hide all elements initially
                document.getElementById('investmentCashSplit').classList.add('hidden');
                document.getElementById('defaultSliders').classList.add('hidden');
                document.getElementById('modelCParameters').style.display = 'none';
                document.getElementById('Title_model_c').style.display = 'none';
                document.getElementById('div_resetThresholdValue').style.display = 'none';
                document.getElementById('alwaysUseHighestPeakOption').style.display = 'none';
                holdingRatioResult.style.display = 'none';

                // Reset variables and UI states
                alwaysUseHighestPeak = false;
                alwaysUseHighestPeakYesBtn.classList.remove('active');
                alwaysUseHighestPeakNoBtn.classList.add('active');

                // **Reset sliders to default values**
                splitSlider.value = 50; // Default value for Investment vs. Cash Split
                splitValue.textContent = "50%";
                buyThresholdSlider.value = 5; // Default value for Buy Threshold
                buyThresholdValue.textContent = "5%";
                sellThresholdSlider.value = 10; // Default value for Sell Threshold
                sellThresholdValue.textContent = "10%";
                buyAmountPercentSlider.value = 10; // Default value for Buy Percentage from Cash
                buyAmountPercentValue.textContent = "10%";

                if (model === 'modelDIcon') {
                    // **Model D**: Show only the Reset Threshold slider
                    document.getElementById('div_resetThresholdValue').style.display = 'block';
                    // Show Holding Ratio in Results
                    holdingRatioResult.style.display = 'flex';
                } else if (model === 'modelCIcon') {
                    // **Model C**: Show only the Investment vs. Cash Split slider
                    document.getElementById('investmentCashSplit').classList.remove('hidden');
                    // Show Model C Customization (if applicable)
                    document.getElementById('modelCParameters').style.display = 'block';
                    document.getElementById('Title_model_c').style.display = 'block';
                } else if (model === 'modelBIcon') {
                    // **Model B**: Show default sliders and 'Always Use Highest Peak' option
                    document.getElementById('investmentCashSplit').classList.remove('hidden');
                    document.getElementById('defaultSliders').classList.remove('hidden');
                    document.getElementById('alwaysUseHighestPeakOption').style.display = 'block';
                    // Show Buy Amount on Each Purchase and Available Investment Cash in results
                    document.querySelector('.result-item:nth-child(2)').style.display = 'flex';
                    document.querySelector('.result-item:nth-child(3)').style.display = 'flex';
                } else {
                    document.getElementById('alwaysUseHighestPeakOption').style.display = 'block';
                    document.getElementById('investmentCashSplit').classList.remove('hidden');
                    // **Model A**: Show default sliders
                    document.getElementById('defaultSliders').classList.remove('hidden');
                    // Show Buy Amount on Each Purchase and Available Investment Cash in results
                    document.querySelector('.result-item:nth-child(2)').style.display = 'flex';
                    document.querySelector('.result-item:nth-child(3)').style.display = 'flex';
                }

                selectedModel = model.replace('Icon', '');
                console.log('Selected strategy:', selectedModel);
                debouncedCalculateResults();
            }

            [modelAIcon, modelBIcon, modelCIcon, modelDIcon].forEach(function (button) {
                button.addEventListener('click', function () {
                    selectModel(this.id);
                });
            });

            // Initialize the UI with the default model (Model B)
            selectModel('modelBIcon');
        };

        function setupCustomRangeSelector() {
            const buttons = document.querySelectorAll('#customRangeSelector button');
            buttons.forEach(button => {
                button.addEventListener('click', function() {
                    // Remove 'active' class from all buttons
                    buttons.forEach(btn => btn.classList.remove('active'));
                    // Add 'active' class to the clicked button
                    this.classList.add('active');

                    // Determine the new date range
                    const range = this.getAttribute('data-range');
                    let newStartDate;
                    const endDate = new Date(maxXValue); // Use the globally scoped maxXValue

                    if (range === 'max') {
                        newStartDate = new Date(minXValue);
                    } else {
                        const yearsBack = parseInt(range.replace('y', ''));
                        newStartDate = new Date(Date.UTC(endDate.getUTCFullYear() - yearsBack, endDate.getUTCMonth(), endDate.getUTCDate()));
                    }

                    // Update the chart's x-axis range
                    Plotly.relayout('totalPortfolioChart', {
                        'xaxis.range': [newStartDate, endDate]
                    });

                    // Update the date inputs or recalculate results
                    updateDateDropdowns(newStartDate, endDate);
                });
            });
        }

        // Function to add a new row to the Model C table
        function addRow() {
            const tableBody = document.querySelector('#modelCTable tbody');
            const rowCount = tableBody.rows.length;

            const row = tableBody.insertRow();

            // Drop Percentage cell
            const cellDropPercentage = row.insertCell(0);
            const dropPercentageInput = document.createElement('input');
            dropPercentageInput.type = 'number';
            dropPercentageInput.max = '100';
            dropPercentageInput.step = '1';
            dropPercentageInput.style.width = '100%';

            // Set default value based on the previous row's drop percentage
            let previousDropPercentage = 0;
            if (rowCount > 0) {
                const previousRow = tableBody.rows[rowCount - 1];
                const previousDropInput = previousRow.cells[0].querySelector('input');
                previousDropPercentage = parseFloat(previousDropInput.value);
                // Set the min attribute
                dropPercentageInput.min = previousDropPercentage + 1;
                // Add event listener to update min of this input when previous input changes
                previousDropInput.addEventListener('input', () => {
                    const newMin = parseFloat(previousDropInput.value) + 1;
                    dropPercentageInput.min = newMin;
                    if (parseFloat(dropPercentageInput.value) < newMin) {
                        dropPercentageInput.value = newMin;
                    }
                    updateMinValuesFromRow(row.rowIndex - 1);
                });
            } else {
                dropPercentageInput.min = '1';
            }
            
            dropPercentageInput.min = previousDropPercentage + 1; // Set the min attribute
            dropPercentageInput.value = previousDropPercentage + 5; // Default increment

            dropPercentageInput.style.width = '100%';
            dropPercentageInput.addEventListener('input', () => {
                collectData();
                debounce(calculateResults, 300)();
            });
            cellDropPercentage.appendChild(dropPercentageInput);
            cellDropPercentage.style.border = '1px solid #ddd';
            cellDropPercentage.style.padding = '8px';

            // Buy Percentage from Cash cell
            const cellBuy = row.insertCell(1);
            const buyInput = document.createElement('input');
            buyInput.type = 'number';
            buyInput.min = '0';
            buyInput.max = '100';
            buyInput.step = '1';
            buyInput.value = '10';
            buyInput.style.width = '100%';
            buyInput.addEventListener('input', () => {
                collectData();
                debounce(calculateResults, 300)();
            });
            cellBuy.appendChild(buyInput);
            cellBuy.style.border = '1px solid #ddd';
            cellBuy.style.padding = '8px';

            // Sell Threshold cell
            const cellSell = row.insertCell(2);
            const sellInput = document.createElement('input');
            sellInput.type = 'number';
            sellInput.min = '0';
            sellInput.max = '100';
            sellInput.step = '5';
            sellInput.value = '5';
            sellInput.style.width = '100%';
            sellInput.addEventListener('input', () => {
                collectData();
                debounce(calculateResults, 300)();
            });
            cellSell.appendChild(sellInput);
            cellSell.style.border = '1px solid #ddd';
            cellSell.style.padding = '8px';

            collectData();
        }

        // Function to remove the last row from the Model C table
        function removeRow() {
            const tableBody = document.querySelector('#modelCTable tbody');
            if (tableBody.rows.length > 0) {
                tableBody.deleteRow(-1);
                collectData();
                debounce(calculateResults, 300)();
            }
        }

        // Function to collect data from the Model C table
        function collectData() {
            buyPercentages = [];
            sellPercentages = [];
            dropPercentages = [];

            const tableBody = document.querySelector('#modelCTable tbody');
            let previousDropPercentage = 0;
            
            // Get all rows in the tbody
            const rows = tableBody.rows;
            for (let row of tableBody.rows) {
                const dropPercentageInput = row.cells[0].querySelector('input');
                const buyInput = row.cells[1].querySelector('input');
                const sellInput = row.cells[2].querySelector('input');

                const dropPercentage = parseFloat(dropPercentageInput.value);

                if (isNaN(dropPercentage) || dropPercentage <= previousDropPercentage) {
                    dropPercentageInput.style.borderColor = 'red';
                    return; // Skip this row but continue processing others
                } else {
                    dropPercentageInput.style.borderColor = '';
                    previousDropPercentage = dropPercentage;
                }

                dropPercentages.push(dropPercentage / 100);
                buyPercentages.push(parseFloat(buyInput.value) / 100);
                sellPercentages.push(parseFloat(sellInput.value) / 100);
            }
        }

        function parseCSVData(csvText, type) {
            // CSV parsing remains the same
            Papa.parse(csvText, {
                header: true,
                dynamicTyping: true,
                complete: function(results) {
                    console.log(`CSV data parsed successfully for ${type}.`);

                    const parsedData = results.data
                        .filter(row => {
                            const dateStr = row['Date'];
                            const price = row['Close'];
                            const openPrice = row['Open'];
                            const highPrice = row['High'];
                            const lowPrice = row['Low'];

                            if (!dateStr || isNaN(price) || isNaN(openPrice)) {
                                console.warn(`Skipping invalid row in ${type} data:`, row);
                                return false;
                            }
                            return true;
                        })
                        .map(row => {
                            const dateStr = row['Date'].trim();
                            const [dayStr, monthStr, yearStr] = dateStr.split('/');
                            const day = parseInt(dayStr);
                            const month = parseInt(monthStr);
                            const year = parseInt(yearStr);

                            return {
                                date: dateStr,
                                price: row['Close'],
                                openPrice: row['Open'],
                                highPrice: row['High'],
                                lowPrice: row['Low'],
                                dateObj: new Date(Date.UTC(year, month - 1, day))
                            };
                        });

                    if (parsedData.length > 0) {
                        if (type === 'QLD') {
                            stockData = parsedData;
                            console.log("QLD stock data loaded. Total entries:", stockData.length);
                        } else if (type === 'NDX') {
                            ndxStockData = parsedData;
                            console.log("NDX stock data loaded. Total entries:", ndxStockData.length);
                        }

                        datasetsLoaded++;
                        if (datasetsLoaded === 2) {
                            populateDateDropdown();
                            setupChart();
                            calculateResults();
                        }
                    } else {
                        console.error(`Invalid data: No valid stock data found for ${type}.`);
                        finalTotalValueDisplay.textContent = 'Invalid data';
                    }
                },
                error: function(error) {
                    console.error(`Error parsing CSV data for ${type}:`, error);
                }
            });
        }

        function populateDateDropdown() {
            // Combine and extract unique date objects from both datasets
            const combinedDates = [...stockData, ...ndxStockData].map(data => data.dateObj.getTime());
            const uniqueDatesSet = new Set(combinedDates);
            const uniqueDates = Array.from(uniqueDatesSet).map(time => new Date(time));

            // Sort the dates in ascending order
            uniqueDates.sort((a, b) => a - b);

            // Clear existing options
            dateRangeDropdown.innerHTML = '';
            closingDateDropdown.innerHTML = '';

            // Populate both dropdowns with sorted dates
            uniqueDates.forEach(dateObj => {
                const dateStr = formatDate(dateObj);

                const option1 = document.createElement('option');
                option1.value = dateStr;
                option1.textContent = dateStr;
                dateRangeDropdown.appendChild(option1);

                const option2 = document.createElement('option');
                option2.value = dateStr;
                option2.textContent = dateStr;
                closingDateDropdown.appendChild(option2);
            });

            // Set default start and end dates
            const defaultStartDate = '26/07/2019';
            const defaultStartExists = Array.from(dateRangeDropdown.options).some(option => option.value === defaultStartDate);

            if (defaultStartExists) {
                dateRangeDropdown.value = defaultStartDate;
            } else {
                dateRangeDropdown.value = formatDate(uniqueDates[0]);
            }

            // Set default end date to the latest available date
            closingDateDropdown.value = formatDate(uniqueDates[uniqueDates.length - 1]);

            // Initialize the end date options based on the default start date
            synchronizeEndDateOptions();

            calculateResults();
        }

        function synchronizeEndDateOptions() {
            const selectedStartDate = parseDate(dateRangeDropdown.value);
            const allEndOptions = Array.from(closingDateDropdown.options);

            allEndOptions.forEach(option => {
                const optionDate = parseDate(option.value);
                if (optionDate >= selectedStartDate) {
                    option.disabled = false;
                    option.style.display = ''; // Ensure it's visible
                } else {
                    option.disabled = true;
                    option.style.display = 'none'; // Hide invalid options
                }
            });

            // If the currently selected end date is now invalid, reset it to the start date
            const selectedEndDate = parseDate(closingDateDropdown.value);
            if (selectedEndDate < selectedStartDate) {
                closingDateDropdown.value = dateRangeDropdown.value;
            }
        }

        async function calculateResults() {
            try {
            showLoadingOverlay(); // Show the loading overlay
            await new Promise(resolve => setTimeout(resolve, 0)); // Yield to the browser to render the overlay

            console.log("Starting calculations...");

            collectData(); // Ensure we have the latest data for modeL c

            const buyPoints = [];
            const sellPoints = [];
            const totalCashValues = [];
            const resetPoints = [];
            const buyCountsPerDate = {};
            const sellCountsPerDate = {};
            const OFFSET_INCREMENT = 500 * 60 * 1000;
            const selectedStartDate = dateRangeDropdown.value;
            const selectedClosingDate = closingDateDropdown.value;
            const startDateObj = parseDate(selectedStartDate);
            const endDateObj = parseDate(selectedClosingDate);

            const filteredStockData = getFilteredStockData(stockData, startDateObj, endDateObj);
            const filteredNDXStockData = getFilteredStockData(ndxStockData, startDateObj, endDateObj);

            if (!filteredStockData.length || !filteredNDXStockData.length) {
                console.error("No stock data available for the selected date range.");
                finalTotalValueDisplay.textContent = 'No data';
                updateChart([], [], [], [], []);
                hideLoadingOverlay(); // Hide the overlay if no data is found
                return;
            }

            let totalPortfolioValue = parseInt(totalInvestmentInput.value);
            let cashPercent = parseInt(splitSlider.value) / 100;
            let buyThreshold = parseFloat(buyThresholdSlider.value) / 100;
            let sellThreshold = parseFloat(sellThresholdSlider.value) / 100;
            let ndxInitialInvestment = parseInt(totalInvestmentInput.value);
            let initialCash = totalPortfolioValue * cashPercent;
            let cash = initialCash;
            let initialPassiveInvestment = totalPortfolioValue * (1 - cashPercent);
            let passiveShares = initialPassiveInvestment / filteredStockData[0].openPrice;
            let passiveInvestmentPrice = filteredStockData[0].openPrice;
            let activeInvestments = [];
            let highestPeak = filteredStockData[0].price;
            let lastBuyPrice = filteredStockData[0].highPrice;
            let currentPeak = highestPeak;
            let purchaseCount = 0;
            let activeCashInvested = 0;
            let activeInvestmentValue = 0;
            let passivePortfolioValue = 0;
            let totalValue = 0;
            let dropFromHighestPeak = 0;
            let gainPercentage = 0;
            let currentPurchaseCount = 0;
            let dropPercentage = 0;
            let cumulativeDropPercentage = 0;
            let sharesToBuy = 0;
            let purchaseOnDayCount = 0;
            let sellOnDayCount = 0;
            let totalProfit = 0;
            let firstPurchasePeak = null;
            let fullySold = true;
            let bought = false;
            let buyAmountPercent = 0;
            // Variables specific to Model D
            let modelDPortfolioValue = totalPortfolioValue;
            let modelDInvestments = [{
                buyPrice: filteredStockData[0].openPrice,
                shares: (totalPortfolioValue - initialCash) / filteredStockData[0].openPrice
            }];        

            let ndxPassiveShares = ndxInitialInvestment / filteredNDXStockData[0].openPrice;
            let ndxPortfolioValues = filteredNDXStockData.map(data => {
                return {
                    x: data.dateObj,
                    y: ndxPassiveShares * data.price
                };
            });

            // Ensure initial QLD investment is set to $100,000
            let initialQLDInvestment = totalPortfolioValue; // Set to $100,000
            let qldPassiveShares = initialQLDInvestment / filteredStockData[0].openPrice;

            // Calculate QLD yield values as percentages starting from 100%
            let qldYieldValues = filteredStockData.map(data => {
                const currentValue = (qldPassiveShares * data.price);
                const yieldPercentage = ((currentValue / initialQLDInvestment) - 1) * 100; // Starts at 0%
                
                return {
                    x: data.dateObj,
                    y: yieldPercentage
                };
            });

            const totalPortfolioValues = [];
            const activeProfits = [];
            const transactionLog = [];
            
            // Iterate over filtered stock data for calculations
            filteredStockData.forEach((data, index) => {
                const dataDate = data.dateObj;
                let price = data.price;
                let action = 'Hold';
                let sharesBought = 0;
                let sharesSold = 0;
                let didBuy = false;
                let didSell = false;
                let dailyBuyShares = 0;
                let dailyBuyPrices = [];
                fullySold = (activeInvestments.length === 0);

                // Update the highest peak (always check if price exceeds the highestPeak)
                if (data.price > highestPeak) {
                    highestPeak = data.price;
                }

                // If fully sold, reset the first purchase peak and purchase count
                if (fullySold) {
                    firstPurchasePeak = highestPeak;
                    purchaseCount = 0; // Reset purchase count
                }

                let buy_price = null;
                let sellPrice = null;
                let buyPricesLog = ''; // Initialize a variable to store buy prices for the day
                let peakToUse;

                if (alwaysUseHighestPeak && selectedModel === 'modelB') {
                    peakToUse = highestPeak;
                } else {
                    peakToUse = fullySold ? highestPeak : firstPurchasePeak;
                }

                // Adjust currentPeak based on the selected model
                if (alwaysUseHighestPeak && selectedModel === 'modelA') {
                    currentPeak = highestPeak; // Always use the highest peak for Model A if the option is enabled
                } else if (fullySold) {
                    currentPeak = highestPeak; // Use the highest peak if all investments have been sold
                }

                if (selectedModel === 'modelB') {
                    currentPeak = highestPeak - highestPeak * buyThreshold * activeInvestments.length; // Model B logic
                }

                if (selectedModel === 'modelD') {
                    const resetThreshold = parseFloat(resetThresholdSlider.value) / 100;
                    const lowerBound = totalPortfolioValue * (1 - resetThreshold);
                    const upperBound = totalPortfolioValue * (1 + resetThreshold);

                    // Calculate current Model D portfolio value
                    modelDPortfolioValue = cash + modelDInvestments.reduce((sum, inv) => sum + inv.shares * data.price, 0);

                    // Check if the Model D portfolio should be reset
                    if (modelDPortfolioValue <= lowerBound || modelDPortfolioValue >= upperBound) {
                        // Store the previous portfolio value before reset
                        const previousPortfolioValue = modelDPortfolioValue;

                        // Determine if the reset is due to a drop or a rise
                        const resetDueToDrop = modelDPortfolioValue <= lowerBound;

                        // Calculate the adjustment needed to reset the portfolio value to initial value
                        const adjustment = totalPortfolioValue - modelDPortfolioValue;

                        // Adjust cash to reflect the injection or withdrawal of funds
                        cash += adjustment;

                        // Sell all investments
                        const saleProceeds = modelDInvestments.reduce((sum, inv) => sum + inv.shares * data.price, 0);
                        cash += saleProceeds;
                        modelDInvestments = [];

                        // Calculate investment amount based on cashPercent
                        const investmentAmount = cash * (1 - cashPercent);

                        // Deduct investment amount from cash
                        cash -= investmentAmount;

                        // Buy new investments
                        const sharesToBuy = investmentAmount / data.price;
                        modelDInvestments.push({ buyPrice: data.price, shares: sharesToBuy });

                        // Recalculate portfolio value
                        modelDPortfolioValue = cash + sharesToBuy * data.price;

                        // Set marker properties based on whether reset is due to drop or rise
                        const markerProperties = resetDueToDrop
                            ? { color: 'red', symbol: 'triangle-down', size: 15 }
                            : { color: 'green', symbol: 'triangle-up', size: 15 };

                        // Push the reset point with the updated marker properties
                        resetPoints.push({
                            x: dataDate,
                            y: modelDPortfolioValue,
                            marker: markerProperties,
                            hovertext: `Reset on ${data.date}:<br>Portfolio Value Before Reset: $${previousPortfolioValue.toFixed(2)}<br>Adjusted Portfolio Value: $${modelDPortfolioValue.toFixed(2)}<br>Remaining Cash: $${cash.toFixed(2)}`
                        });

                        action = 'Reset';
                    }
                }

                // Calculate drop from current peak
                const dropFromCurrentPeak = ((currentPeak - price) / currentPeak) * 100;
                dropFromHighestPeak = ((highestPeak - data.lowPrice) / highestPeak) * 100;

                // **Calculate portfolio values before buy/sell logic**
                activeInvestmentValue = cash + activeInvestments.reduce((sum, inv) => sum + inv.shares * price, 0);
                passivePortfolioValue = passiveShares * price;
                totalValue = (activeInvestments.reduce((sum, inv) => sum + inv.shares, 0) + passiveShares) * data.price + cash;

                // Buy logic
                if (selectedModel === 'modelA' || selectedModel === 'modelB') {
                    buyAmountPercent = parseFloat(buyAmountPercentSlider.value) / 100;
                    let initialBuyAmount = initialCash * buyAmountPercent;

                    if (dropFromCurrentPeak >= buyThreshold * 100) {
                        // Loop to check for multiple purchases on the same day
                        while (dropFromCurrentPeak >= buyThreshold * 100) {
                            currentPurchaseCount = activeInvestments.length + 1; // Increment based on the number of purchases made
                            dropPercentage = buyThreshold * currentPurchaseCount * 100; // Calculate the specific drop percentage
                            cumulativeDropPercentage = buyThreshold * currentPurchaseCount * 100; // Calculate the cumulative drop percentage

                            // Calculate the new buy price based on the selected model
                            if (selectedModel === 'modelA') {
                                buy_price = fullySold ? currentPeak * (1 - buyThreshold) : activeInvestments[activeInvestments.length - 1]['buyPrice'] * (1 - buyThreshold);
                            } else if (selectedModel === 'modelB') {
                                buy_price = peakToUse - peakToUse * buyThreshold * currentPurchaseCount;
                            }

                            // Shares to buy calculation
                            sharesToBuy = initialBuyAmount / buy_price;

                            // **Calculate drop from the highest peak using the buy price** (Used in conjunction with modelA)
                            dropFromHighestPeak = ((highestPeak - buy_price) / highestPeak) * 100;
                            // Determine marker properties based on the cumulative drop percentage
                            let markerProperties = getMarkerProperties('buy', cumulativeDropPercentage);

                            // **Additional check: Ensure the low price of the day is below or equal to the buy price**
                            if (data.lowPrice < buy_price && (cash >= sharesToBuy * buy_price || (allowNegativeBalance && cash < sharesToBuy * buy_price))) {
                                // Check if there is enough cash to buy the shares
                                cash -= sharesToBuy * buy_price;
                                // Store the color with the investment
                                activeInvestments.push({ buyPrice: buy_price, shares: sharesToBuy, color: markerProperties.color });
                                // Increment if multiple buys are made
                                sharesBought += sharesToBuy;
                                activeCashInvested += sharesToBuy * buy_price;
                                // increment purchase count on a single day
                                purchaseOnDayCount++;
                                // Append the buy price to the log string
                                buyPricesLog = buyPricesLog === '' ? buy_price.toFixed(4) : `${buyPricesLog}; ${buy_price.toFixed(4)}`;
                                action = 'Buy';
                                didBuy = true;
                                // Update currentPeak for subsequent buys
                                currentPeak = buy_price;

                                // Increment buy count
                                const dateKey = dataDate.toISOString().split('T')[0];
                                buyCountsPerDate[dateKey] = (buyCountsPerDate[dateKey] || 0) + 1;
                                const buyCount = buyCountsPerDate[dateKey];
                                // Calculate xOffset
                                const xOffset = buyCount * OFFSET_INCREMENT;

                                // Determine the hover text based on the selected model
                                let hoverText = '';
                                if (selectedModel === 'modelA') {
                                    hoverText = `Buy (Model A): ${data.date}, Drop from Highest Peak: ${dropFromHighestPeak.toFixed(2)}%, Price: $${buy_price.toFixed(2)}, Bought: ${sharesToBuy.toFixed(2)} shares`;
                                } else if (selectedModel === 'modelB') {
                                    hoverText = `Buy (Model B): ${data.date}, Drop: ${cumulativeDropPercentage.toFixed(2)}%, Price: $${buy_price.toFixed(2)}, Bought: ${sharesToBuy.toFixed(2)} shares`;
                                }

                                // Add buy point with adjusted x-value
                                buyPoints.push({
                                    x: new Date(dataDate.getTime() + xOffset),
                                    y: totalValue,
                                    marker: {
                                        color: markerProperties.color,
                                        symbol: 'circle',
                                        size: 8,
                                        line: { width: 1 }
                                    },
                                    hovertext: hoverText
                                });
                            } else {
                                break; // Break the loop if the low price is not suitable for a buy
                            }
                            // Recalculate drop from current peak after the purchase
                            const newDropFromCurrentPeak = ((currentPeak - price) / currentPeak) * 100;
                            if (newDropFromCurrentPeak < buyThreshold * 100) {
                                break; // Break the loop if no further purchases can be made
                            }
                        }
                    }
                } else {
                    // Model C Buy Logic
                    // For each drop level, check if we should buy
                    // Sort dropPercentages and corresponding buy and sell percentages
                    const sortedLevels = dropPercentages.map((drop, index) => ({
                        drop: drop,
                        buyPercentage: buyPercentages[index],
                        sellThreshold: sellPercentages[index]
                    })).sort((a, b) => a.drop - b.drop);

                    for (let i = 0; i < sortedLevels.length; i++) {
                        const level = sortedLevels[i];
                        cumulativeDropPercentage = level.drop;
                        if (dropFromHighestPeak >= cumulativeDropPercentage * 100 && !activeInvestments.some(inv => inv.dropLevel === i)) {
                            // Calculate buy price
                            buy_price = highestPeak * (1 - cumulativeDropPercentage);
                            let buyPercentageFromCash = level.buyPercentage;
                            let amountToInvest = initialCash * buyPercentageFromCash;

                            sharesToBuy = amountToInvest / buy_price;

                            // Ensure we have enough cash
                            if (cash >= amountToInvest || (allowNegativeBalance && cash < amountToInvest)) {
                                cash -= amountToInvest;
                                activeInvestments.push({
                                    buyPrice: buy_price,
                                    shares: sharesToBuy,
                                    color: getMarkerProperties('buy', cumulativeDropPercentage * 100).color,
                                    dropLevel: i,
                                    sellThreshold: level.sellThreshold
                                });
                                sharesBought += sharesToBuy;
                                activeCashInvested += sharesToBuy * buy_price;
                                purchaseOnDayCount++;
                                buyPricesLog = buyPricesLog === '' ? buy_price.toFixed(4) : `${buyPricesLog}; ${buy_price.toFixed(4)}`;
                                action = 'Buy';
                                didBuy = true;

                                // Log the buy point
                                const dateKey = dataDate.toISOString().split('T')[0];
                                buyCountsPerDate[dateKey] = (buyCountsPerDate[dateKey] || 0) + 1;
                                const buyCount = buyCountsPerDate[dateKey];
                                const xOffset = buyCount * OFFSET_INCREMENT;

                                buyPoints.push({
                                    x: new Date(dataDate.getTime() + xOffset),
                                    y: totalValue,
                                    marker: {
                                        color: getMarkerProperties('buy', cumulativeDropPercentage * 100).color,
                                        symbol: 'circle',
                                        size: 8,
                                        line: { width: 1 }
                                    },
                                    hovertext: `Buy (Model C): ${data.date}, Drop: ${(cumulativeDropPercentage * 100).toFixed(2)}%, Price: $${buy_price.toFixed(2)}, Bought: ${sharesToBuy.toFixed(2)} shares`
                                });
                            }
                        }
                    }
                }

                // Sell logic
                activeInvestments = activeInvestments.map(investment => {
                    let targetSellPrice;
                    if (selectedModel === 'modelC') {
                        targetSellPrice = investment.buyPrice * (1 + investment.sellThreshold);
                    } else {
                        targetSellPrice = investment.buyPrice * (1 + sellThreshold);
                    }
                    if (data.highPrice >= targetSellPrice) {
                        let saleProceeds = investment.shares * targetSellPrice;
                        totalProfit += (saleProceeds - (investment.shares * investment.buyPrice));
                        cash += saleProceeds;
                        sharesSold += investment.shares;
                        action = 'Sell';
                        didSell = true;
                        sellPrice = targetSellPrice;
                        sellOnDayCount++;
                        gainPercentage = ((targetSellPrice - investment.buyPrice) / investment.buyPrice) * 100;

                        // Increment sell count
                        const dateKey = dataDate.toISOString().split('T')[0];
                        sellCountsPerDate[dateKey] = (sellCountsPerDate[dateKey] || 0) + 1;
                        const sellCount = sellCountsPerDate[dateKey];
                        const xOffset = sellCount * OFFSET_INCREMENT;

                        // Log the sell point
                        sellPoints.push({
                            x: new Date(dataDate.getTime() + xOffset),
                            y: totalValue,
                            marker: {
                                color: investment.color,
                                symbol: 'star',
                                size: 8
                            },
                            hovertext: `Sell: ${data.date}, Gain: ${gainPercentage.toFixed(2)}%, Price: $${sellPrice.toFixed(2)}, Sold: ${investment.shares.toFixed(2)} shares`
                        });

                        return { ...investment, shares: 0 };
                    }
                    return investment;
                }).filter(investment => investment.shares > 0);

                const passiveProfit = (price - passiveInvestmentPrice) * passiveShares;
                const activeProfit = totalProfit + activeInvestments.reduce((sum, inv) => sum + inv.shares * price, 0);
                const ndxDataMap = new Map(filteredNDXStockData.map(item => [item.date, item]));
                const ndxData = ndxDataMap.get(data.date);
                const ndxYield = ndxData ? ((ndxData.price / filteredNDXStockData[0].openPrice) - 1) * 100 : 'N/A';
                const modelYield = ((totalValue  / totalPortfolioValue) - 1) * 100; // Corrected Yield Calculation
                const ndxPassiveValue = ndxPortfolioValues[index].y;
                const qldYield = ((data.price / filteredStockData[0].openPrice) - 1) * 100;
                const totalInvestments = data.price * (activeInvestments.reduce((sum, inv) => sum + inv.shares, 0) + passiveShares)
                const leveragedHoldings = totalInvestments * 2
                const LeveragedHoldingPercentage = (leveragedHoldings / totalValue) * 100
                const cashRatio = totalPortfolioValue / totalValue

                if (selectedModel === 'modelD') {
                    const modelDInvestmentValue = modelDInvestments.reduce((sum, inv) => sum + inv.shares * data.price, 0);
                    console.log('Cash', {cash}, 'modelDinvestmentvalue', {modelDInvestmentValue}, "date", {data})
                    totalValue = cash + modelDInvestmentValue;
                    totalCashValues.push({ x: dataDate, y: cash });
                } else {
                    // Do not redeclare variables; just assign values
                    activeInvestmentValue = activeInvestments.reduce((sum, inv) => sum + inv.shares * data.price, 0);
                    passiveInvestmentValue = passiveShares * data.price;
                    totalValue = activeInvestmentValue + passiveInvestmentValue + cash;
                    totalCashValues.push({ x: dataDate, y: cash });
                }

                totalPortfolioValues.push({ x: dataDate, y: totalValue });

                // Modify the transaction log to store the new price fields
                transactionLog.push({
                    date: data.date,
                    action: action,
                    sharesBought: sharesBought,
                    sharesSold: sharesSold,
                    openPrice: data.openPrice,
                    lastBuy: buyPricesLog, // Log multiple buy prices
                    sellPrice: sellPrice,
                    highPrice: data.highPrice,
                    lowPrice: data.lowPrice,
                    closePrice: data.price,
                    totalCash: cash.toFixed(2),
                    stocksHeld: (selectedModel === 'modelD' ? modelDInvestments.reduce((sum, inv) => sum + inv.shares, 0) : activeInvestments.reduce((sum, inv) => sum + inv.shares, 0)).toFixed(2),
                    passiveShares: passiveShares,
                    totalShares: ((selectedModel === 'modelD' ? modelDInvestments.reduce((sum, inv) => sum + inv.shares, 0) : activeInvestments.reduce((sum, inv) => sum + inv.shares, 0)) + passiveShares).toFixed(2),
                    totalInvestments: totalInvestments.toFixed(2),
                    leveragedHolding: leveragedHoldings.toFixed(2),
                    LeveragedHoldingPercentage: LeveragedHoldingPercentage,
                    cashRatio: cashRatio,
                    highestPeak: highestPeak,
                    downPercentageFromPeak: dropFromHighestPeak.toFixed(2),
                    passiveInvestmentPrice: passiveInvestmentPrice,
                    passiveProfit: passiveProfit.toFixed(2),
                    activeProfit: activeProfit.toFixed(2),
                    activeCashInvested: activeCashInvested.toFixed(2),
                    totalValue: totalValue.toFixed(2),
                    totalAmount: (cash + passivePortfolioValue).toFixed(2),
                    modelDPortfolioValue: modelDPortfolioValue.toFixed(2),
                    valuePassive: (passiveShares * data.price).toFixed(2),
                    ndxOpen: ndxData ? ndxData.openPrice : 'N/A',
                    ndxClosePrice: ndxData ? ndxData.price : 'N/A',
                    ndxPassive: ndxPassiveValue.toFixed(2),
                    ndxYield: ndxData ? ndxYield.toFixed(2) : 'N/A',
                    modelYield: modelYield.toFixed(2),
                    qldYield: qldYield.toFixed(2),
                });
            });

            // Find the max and min values of the primary y-axis data
            const portfolioValues = totalPortfolioValues.map(data => data.y);
            const primaryYMin = Math.min(...portfolioValues);
            const primaryYMax = Math.max(...portfolioValues);

            // Scale QLD Yield to the primary y-axis range
            const qldYieldScaledValues = qldYieldValues.map(data => {
                const scaledY = ((data.y / 100) * (primaryYMax - primaryYMin)) + primaryYMin;
                return {
                    x: data.x,
                    y: scaledY,
                    originalYield: data.y, // Keep the original yield for hover info
                };
            });

            const finalPortfolioValue = totalPortfolioValues[totalPortfolioValues.length - 1].y;
            buyAmountDisplay.textContent = selectedModel !== 'modelC' ? Math.floor(initialCash * buyAmountPercent).toFixed(0) : 'Dynamic';
            finalTotalValueDisplay.textContent = totalValue.toFixed(2);
            stocksLeftDisplay.textContent = activeInvestments.reduce((sum, inv) => sum + inv.shares, 0).toFixed(2);
            stocksLeftDisplay.textContent = (selectedModel === 'modelD' ? modelDInvestments.reduce((sum, inv) => sum + inv.shares, 0) : activeInvestments.reduce((sum, inv) => sum + inv.shares, 0)).toFixed(2);
            availableMoneyDisplay.textContent = (selectedModel === 'modelD' ? cash : cash).toFixed(2);

            // Calculate yields for result tab (Final values)
            const finalNDXValue = ndxPortfolioValues[ndxPortfolioValues.length - 1].y;
            const modelYield = ((finalPortfolioValue / totalPortfolioValue) - 1) * 100;
            const ndxYield = ((finalNDXValue / ndxInitialInvestment) - 1) * 100;

            // Display yields in results
            document.getElementById('modelYield').textContent = modelYield.toFixed(2);
            document.getElementById('ndxYield').textContent = ndxYield.toFixed(2);

            // Daily cumulative yield calculation for both QLD and NDX
            const qldCumulativeYields = totalPortfolioValues.map(data => {
                return {
                    x: data.x,
                    y: ((data.y / totalPortfolioValue) - 1) * 100
                };
            });

            const ndxCumulativeYields = ndxPortfolioValues.map(data => {
                return {
                    x: data.x,
                    y: ((data.y / ndxInitialInvestment) - 1) * 100
                };
            });

            updateChart(
                totalPortfolioValues,
                activeProfits,
                ndxPortfolioValues,
                qldYieldScaledValues,
                buyPoints,
                sellPoints,
                totalCashValues,
                resetPoints
            );
            window.transactionLog = transactionLog;

            hideLoadingOverlay(); // Hide the overlay once calculations are complete
                console.log("Calculations completed and overlay hidden.");
            } catch (error) {
                console.error("Error during calculations:", error);
                hideLoadingOverlay(); // Ensure the overlay is hidden even if there's an error
            }
        }

        function parseDate(dateStr) {
            const [dayStr, monthStr, yearStr] = dateStr.trim().split('/');
            const day = parseInt(dayStr);
            const month = parseInt(monthStr);
            const year = parseInt(yearStr);

            if (isNaN(day) || isNaN(month) || isNaN(year)) {
                console.error(`Invalid date format: ${dateStr}`);
                return null;
            }

            return new Date(Date.UTC(year, month - 1, day));
        }

        function formatDate(dateObj) {
            const day = String(dateObj.getDate()).padStart(2, '0');
            const month = String(dateObj.getMonth() + 1).padStart(2, '0');
            const year = dateObj.getFullYear();
            return `${day}/${month}/${year}`;
        }

        function getMarkerProperties(action, threshold) {
            const colorsByThreshold = {
                '5%': 'green',
                '10%': 'cyan',
                '15%': 'purple',
                '20%': 'orange',
                '25%': 'blue',
                '30%': 'magenta',
                '35%': 'brown',
                '40%': 'yellow',
                '45%': 'coral',
                '50%': 'teal',
                '55%': 'olive',
                '60%': 'lime',
                '65%': 'indigo',
                '70%': 'violet',
                '75%': 'gold',
                '80%': 'navy'
            };

            function generateColor(threshold) {
                const hue = Math.round((threshold / 50) * 240);
                return `hsl(${hue}, 100%, 50%)`;
            }

            const color = colorsByThreshold[`${Math.round(threshold)}%`] || generateColor(threshold);

            return {
                color: color,
                shape: 'circle'
            };
        }

        function setupChart() {
            const layout = {
                title: 'Portfolio Values Over Time',
                xaxis: {
                    title: 'Date',
                    type: 'date',
                },
                yaxis: {
                    title: 'Portfolio Value ($)',
                    showline: true,
                    zeroline: false,
                },
                yaxis2: {
                    title: 'QLD Yield (%)',
                    overlaying: 'y',
                    side: 'right',
                    showline: true,
                    zeroline: false,
                },
                hovermode: 'closest',
                legend: {
                    orientation: 'h',
                    x: 0.5,
                    y: 1.15,
                    xanchor: 'center',
                    yanchor: 'bottom',
                    font: {
                        size: 12,
                    },
                },
                margin: {
                    l: 60,
                    r: 80, // Ensure sufficient right margin
                    t: 150,
                    b: 50,
                },
            };

            const config = {
                displaylogo: false,
                displayModeBar: true,
            };

            // Create the chart and get the chart element
            const chartElement = document.getElementById('totalPortfolioChart');
            Plotly.newPlot(chartElement, [], layout, config);

            // Add event listener for relayout events
            chartElement.on('plotly_relayout', function(eventData) {
                if (eventData['xaxis.range[0]'] && eventData['xaxis.range[1]']) {
                    const newStartDate = new Date(eventData['xaxis.range[0]']);
                    const newEndDate = new Date(eventData['xaxis.range[1]']);

                    // Update the date dropdowns
                    updateDateDropdowns(newStartDate, newEndDate);
                }
            });
        }

        function updateDateDropdowns(newStartDate, newEndDate) {
            // Format dates to match the format used in the dropdowns
            const formattedStartDate = formatDate(newStartDate);
            const formattedEndDate = formatDate(newEndDate);

            // Find the closest matching dates in the dropdown options
            const startDateOption = findClosestDateOption(dateRangeDropdown, formattedStartDate);
            const endDateOption = findClosestDateOption(closingDateDropdown, formattedEndDate);

            // Update the dropdowns if the values have changed
            if (dateRangeDropdown.value !== startDateOption.value) {
                dateRangeDropdown.value = startDateOption.value;
            }
            if (closingDateDropdown.value !== endDateOption.value) {
                closingDateDropdown.value = endDateOption.value;
            }

            // Trigger recalculation if dates have changed
            calculateResults();
        }

        function findClosestDateOption(dropdown, targetDateStr) {
            let closestOption = dropdown.options[0];
            let minDiff = Math.abs(parseDate(dropdown.options[0].value) - parseDate(targetDateStr));

            for (let i = 1; i < dropdown.options.length; i++) {
                const option = dropdown.options[i];
                const optionDate = parseDate(option.value);
                const diff = Math.abs(optionDate - parseDate(targetDateStr));

                if (diff < minDiff) {
                    minDiff = diff;
                    closestOption = option;
                }
            }

            return closestOption;
        }

        function updateChart(totalPortfolioValues, activeProfits, ndxPortfolioValues, qldYieldScaledValues, buyPoints, sellPoints, totalCashValues, resetPoints) {
            qldCumulativeYields = qldCumulativeYields || [];
            ndxCumulativeYields = ndxCumulativeYields || [];

            const allXValues = [
                ...totalPortfolioValues.map(data => data.x),
                ...ndxPortfolioValues.map(data => data.x),
                ...qldYieldScaledValues.map(data => data.x),
                ...buyPoints.map(point => point.x),
                ...sellPoints.map(point => point.x),
                ...resetPoints.map(point => point.x), // Include resetPoints in the x-values calculation
                ...totalCashValues.map(data => data.x),
                ...qldCumulativeYields.map(data => data.x),
                ...ndxCumulativeYields.map(data => data.x)
            ];

            minXValue = Math.min(...allXValues);
            maxXValue = Math.max(...allXValues);
            
            const updatedData = [
                {
                    x: totalPortfolioValues.map(data => data.x),
                    y: totalPortfolioValues.map(data => data.y),
                    name: 'Total Portfolio Value',
                    type: 'scatter',
                    mode: 'lines',
                    line: { color: '#1f77b4', width: 2 },
                    hovertemplate: 'Date: %{x}<br>Total Value: $%{y:.2f}<extra></extra>',
                },
                {
                    x: ndxPortfolioValues.map(data => data.x),
                    y: ndxPortfolioValues.map(data => data.y),
                    name: 'NDX Passive Investment',
                    mode: 'lines',
                },
                {
                    x: qldYieldScaledValues.map(data => data.x),
                    y: qldYieldScaledValues.map(data => data.y),
                    name: 'QLD Yield (%)',
                    mode: 'lines',
                    line: { dash: 'dot', color: 'rgba(0, 128, 128, 1)' },
                    hovertemplate: 'Date: %{x}<br>QLD Yield: %{customdata:.2f}%',
                    customdata: qldYieldScaledValues.map(data => data.originalYield),
                },
                {
                    x: totalCashValues.map(data => data.x),
                    y: totalCashValues.map(data => data.y),
                    name: 'Total Cash',
                    mode: 'lines',
                    line: { dash: 'dot', color: 'rgba(255, 165, 0, 1)' },
                    hovertemplate: 'Date: %{x}<br>Total Cash: $%{y:.2f}<extra></extra>',
                },
                {
                    x: buyPoints.map(point => point.x),
                    y: buyPoints.map(point => point.y),
                    mode: 'markers',
                    name: 'Buy Points',
                    marker: {
                        color: buyPoints.map(point => point.marker.color),
                        symbol: buyPoints.map(point => point.marker.symbol),
                        size: 8,
                    },
                    hoverinfo: 'text',
                    text: buyPoints.map(point => point.hovertext),
                },
                {
                    x: resetPoints.map(point => point.x),
                    y: resetPoints.map(point => point.y),
                    mode: 'markers',
                    name: 'Reset Points',
                    marker: {
                        color: resetPoints.map(point => point.marker.color),
                        symbol: resetPoints.map(point => point.marker.symbol),
                        size: resetPoints.map(point => point.marker.size)
                    },
                    hoverinfo: 'text',
                    text: resetPoints.map(point => point.hovertext)
                },
                {
                    x: sellPoints.map(point => point.x),
                    y: sellPoints.map(point => point.y),
                    mode: 'markers',
                    name: 'Sell Points',
                    marker: {
                        color: sellPoints.map(point => point.marker.color),
                        symbol: sellPoints.map(point => point.marker.symbol),
                        size: 12,
                    },
                    hoverinfo: 'text',
                    text: sellPoints.map(point => point.hovertext),
                }
            ];

            const layout = {
                title: 'Portfolio Values Over Time',
                xaxis: {
                    title: 'Date',
                    type: 'date',
                    range: [minXValue, maxXValue],
                    rangeslider: { visible: false },
                },
                yaxis: {
                    title: 'Value ($) / Yield (%)',
                    
                },
                hovermode: 'closest',
                legend: {
                    orientation: 'h',
                    x: 0.5,
                    y: 1.15,
                    xanchor: 'center',
                    yanchor: 'bottom',
                    font: {
                        size: 12,
                    },
                },
                margin: {
                    l: 50,
                    r: 60,
                    t: 150, // Increased to accommodate the buttons
                    b: 50,
                },
                
            };

            Plotly.react('totalPortfolioChart', updatedData, layout);
        }

        function downloadCSV() {
            const csvRows = [];
            const headers = [
                'Date', 'Action', 'Shares Bought', 'Shares Sold', 'Buy Price', 'Sell Price', 'Open Price', 'High Price', 
                'Low Price', 'Close Price', 'Total Cash', 'Stocks Held', 'Passive Shares', 'Total Shares', 
                'Total Investment', 'Leveraged Holding', 'Leveraged Holding Percentage', 'Cash Ratio', 'Highest Peak', 
                'Passive Profit', 'Active Profit', 'Active Cash Invested', 'Total Value', // 'Model D Portfolio Value',
                'Value Passive', 'Drop % From Highest Peak', 'NDX Open', 'NDX Close', 'NDX Passive Investment', 
                'NDX Yield', 'Model Yield', 'QLD Yield'
            ];
            csvRows.push(headers.join(','));

            window.transactionLog.forEach(log => {
                const row = [
                    log.date,
                    log.action,
                    log.sharesBought,
                    log.sharesSold,
                    log.lastBuy,
                    log.sellPrice,
                    log.openPrice,
                    log.highPrice,
                    log.lowPrice,
                    log.closePrice,
                    log.totalCash,
                    log.stocksHeld,
                    log.passiveShares,
                    log.totalShares,
                    log.totalInvestments,
                    log.leveragedHolding,
                    `${log.LeveragedHoldingPercentage}%`,
                    log.cashRatio,
                    log.highestPeak,
                    log.passiveProfit,
                    log.activeProfit,
                    log.activeCashInvested,
                    log.totalValue,
                    // log.modelDPortfolioValue,
                    log.valuePassive,
                    log.downPercentageFromPeak,
                    log.ndxOpen,
                    log.ndxClosePrice,
                    log.ndxPassive,
                    log.ndxYield,
                    log.modelYield,
                    log.qldYield,
                ];
                csvRows.push(row.join(','));
            });
            const csvContent = csvRows.join('\n');
            const blob = new Blob([csvContent], { type: 'text/csv' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.setAttribute('href', url);
            a.setAttribute('download', 'investment_strategy_log.csv');
            a.click();
        }
    </script>
</body>
</html>
